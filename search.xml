<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[聊聊Java并发6]]></title>
    <url>%2F2017%2F04%2F24%2F%E8%81%8A%E8%81%8AJava%E5%B9%B6%E5%8F%916%2F</url>
    <content type="text"><![CDATA[本文主要介绍了并发中重要的一个模块Queue，通过阅读本文，更加深入熟悉Queue的内容及应用。 并发Queue在并发列上JDK提供两套实现，一个是以ConcurrentLinkedQueue为代表的高性能队列，一个是以BlockingQueue接口为代表的阻塞队列，无论哪种都继承了Queue。 ###ConcurrentLinkedQueue ConcurrentLinkedQueue：是一个适用于高并发场景的队列，通过无锁的方式，实现了并发状态下的高性能，通常ConcurrentLinkedQueue性能好于BlockingQueue。它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则。头是最先加入的，尾是最近加入的。该队列不允许null元素。 ConcurrentLinkedQueue重要方法： add()和offer都是元素的方法ConcurrentLinkedQueue中， 这两个方法没有区别，而别的是： add方法在添加元素的时候，若超出了度列的长度会直接抛出异常 offer方法在添加元素时，如果发现队列已满无法添加的话，会直接返回false put方法，若向队尾添加元素的时候发现队列已经满了会发生阻塞一直等待空间，以加入元素 poll()和peek()都是取头元素节点，去呗在于前者会删除元素，后者不会 12345678910111213141516171819202122232425262728package com.telinx.demo;import java.util.concurrent.LinkedBlockingDeque;public class UseDeque &#123; public static void main(String[] args) &#123; LinkedBlockingDeque&lt;String&gt; dq = new LinkedBlockingDeque&lt;String&gt;(10); dq.addFirst("a"); dq.addFirst("b"); dq.addFirst("c"); dq.addFirst("d"); // dq.offerFirst("k"); System.out.println("查看头元素：" + dq.peekFirst()); System.out.println("获取尾元素：" + dq.pollLast()); Object[] objs = dq.toArray(); for (int i = 0; i &lt; objs.length; i++) &#123; System.out.println(objs[i]); &#125; &#125;&#125;//输出查看头元素：d获取尾元素：adcb BlockingQueue接口ArrayBlockingQueue:基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长的数组，一边缓存队列中的对象，其内部没实现读写分离，也就意味着生产和消费不能完全并行，长度是需要定义的，可以指定先进先出或者后进后出，也叫有界队列，在很多场合非常适合使用。 LinkedBlockingQueue:基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部维持着一个数据缓冲队列（该队列有一个链表构成），LinkedBlockingQueue之所以能够高县的处理并发数据，是因为其内部实现了分离锁（读写分离亮哥锁），从而实现生产者与消费者操作的完全并行运行，他是一个无界队列。 PriorityBlockingQueue:基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入队列的对象必须实现Comparable接口），在实现PriorityBlockingQueue，内部控制线程同步的锁采用的是公平锁，他也是一个无界的队列。 DelayQueue:带有延迟时间的Queue，其中的元素只有当其之指定的延迟时间了，磁能够从队列中获取到该元素。DelayQueue中的元素必须实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务潮湿处理、空闲连接关闭等等。 SyschronousQueue:一种没有缓冲的队列，生产者产生的数据直接回被消费者获取并消费。 优先级 PriorityBlockingQueue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//优先级public class Task implements Comparable&lt;Task&gt; &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public int compareTo(Task task) &#123; // System.out.println("this.id："+ this.id + "对比task.id:" + task.id + // "---------&gt;" + (this.id &gt; task.id ? 1 : (this.id &lt; task.id ? -1 : // 0))); return this.id &gt; task.id ? 1 : (this.id &lt; task.id ? -1 : 0); &#125; public String toString() &#123; return this.id + "," + this.name; &#125;&#125;package com.telinx.demo;import java.util.concurrent.PriorityBlockingQueue;public class UsePriorityBlockingQueue &#123; public static void main(String[] args) throws Exception &#123; PriorityBlockingQueue&lt;Task&gt; q = new PriorityBlockingQueue&lt;Task&gt;(); Task t1 = new Task(); t1.setId(3); t1.setName("id为3"); Task t2 = new Task(); t2.setId(4); t2.setName("id为4"); Task t3 = new Task(); t3.setId(1); t3.setName("id为1"); // return this.id &gt; task.id ? 1 : 0; q.add(t1); // 3 q.add(t2); // 4 q.add(t3); // 1 // 1 3 4 System.out.println("容器：" + q); System.out.println(q.take().getId()); System.out.println("容器：" + q); // System.out.println(q.take().getId()); // System.out.println(q.take().getId()); &#125;&#125;//输出容器：[1,id为1, 4,id为4, 3,id为3]1容器：[3,id为3, 4,id为4] SynchronousQueue也是阻塞队列，但没有内部缓存，使用时需先阻塞take，然后采用add，顺序颠倒发生错误 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.telinx.demo;import java.util.ArrayList;import java.util.List;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.SynchronousQueue;public class UseQueue &#123; public static void main(String[] args) throws Exception &#123; // 高性能无阻塞无界队列：ConcurrentLinkedQueue /** * ConcurrentLinkedQueue&lt;String&gt; q = new ConcurrentLinkedQueue * &lt;String&gt;(); q.offer("a"); q.offer("b"); q.offer("c"); q.offer("d"); * q.add("e"); * * System.out.println(q.poll()); //a 从头部取出元素，并从队列里删除 * System.out.println(q.size()); //4 System.out.println(q.peek()); //b * System.out.println(q.size()); //4 */ /** * ArrayBlockingQueue&lt;String&gt; array = new ArrayBlockingQueue&lt;String&gt;(5); * array.put("a"); array.put("b"); array.add("c"); array.add("d"); * array.add("e"); array.add("f"); //System.out.println(array.offer("a", * 3, TimeUnit.SECONDS)); */ /** * //阻塞队列 LinkedBlockingQueue&lt;String&gt; q = new LinkedBlockingQueue * &lt;String&gt;(); q.offer("a"); q.offer("b"); q.offer("c"); q.offer("d"); * q.offer("e"); q.add("f"); //System.out.println(q.size()); * * // for (Iterator iterator = q.iterator(); iterator.hasNext();) &#123; // * String string = (String) iterator.next(); // * System.out.println(string); // &#125; * * List&lt;String&gt; list = new ArrayList&lt;String&gt;(); * System.out.println(q.drainTo(list, 3)); * System.out.println(list.size()); for (String string : list) &#123; * System.out.println(string); &#125; */ final SynchronousQueue&lt;String&gt; q = new SynchronousQueue&lt;String&gt;(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(q.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t1.start(); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; q.add("asdasd"); &#125; &#125;); t2.start(); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java并发5]]></title>
    <url>%2F2017%2F04%2F23%2F%E8%81%8A%E8%81%8AJava%E5%B9%B6%E5%8F%915%2F</url>
    <content type="text"><![CDATA[本文介绍了java并发的同步并发容器及并发类容器，重点讲述了常用的ConcurrentMap及 Copy-On-Write容器。 同步并发容器同步并发容器都是线程安全的，但在某些场景下可能需要加锁来保护复合操作。复合操作如：迭代（反复访问元素，遍历万容器中所有的元素）、跳转（根据指定的顺序找到当前元素的下一个元素）、一级条件运算。这些复合操作在多线程并发的修改容器时，可能会表现出意外的行为，最经典便是ConcurrentModificationException，原因时当容器迭代的过程中，被并发的修改了内容，这是由于迭代器设计的时候并没有考虑并发修改的问题。 同步类容器：如古老的Vector、HashTable。这些容器的同步功能其实都是JDK的Collections.synchronized*等工厂方法区创建实现的。其底层的机制无非就是用传统的synchronized关键字对每个共用的方法都进行同步，使得每次只能一个线程访问容器的状态。这很明显不满足我们今天互联网时代高并发的需求，在保证线程安全的同时，也必须要有足够好的性能。 Verctor/HashTable只有一个线程读写，性能很low 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.telinx.demo;import java.util.Collections;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Vector;/** * 多线程使用Vector或者HashTable的示例（简单线程同步问题） * * @author alienware */public class Tickets &#123; public static void main(String[] args) &#123; // 初始化火车票池并添加火车票:避免线程同步可采用Vector替代ArrayList HashTable替代HashMap final Vector&lt;String&gt; tickets = new Vector&lt;String&gt;(); // 被这个方法包裹后，这个Mao是线程安全的 // Map&lt;String, String&gt; map = Collections.synchronizedMap(new // HashMap&lt;String, String&gt;()); for (int i = 1; i &lt;= 1000; i++) &#123; tickets.add("火车票" + i); &#125; // for (Iterator iterator = tickets.iterator(); iterator.hasNext();) &#123; // String string = (String) iterator.next(); // tickets.remove(20); // &#125; for (int i = 1; i &lt;= 10; i++) &#123; new Thread("线程" + i) &#123; public void run() &#123; while (true) &#123; if (tickets.isEmpty()) break; System.out.println(Thread.currentThread().getName() + "---" + tickets.remove(0)); &#125; &#125; &#125;.start(); &#125; &#125;&#125;//输出...线程6---火车票997线程6---火车票998线程6---火车票999线程6---火车票1000线程3---火车票591线程8---火车票590线程7---火车票583 ... 并发类容器JDK5以后提供了多种并发类容器来替代同步类容器从而改善性能。同步类容器的状态都是串兴化的。他们虽然实现了线程安全，单严重降低了并发性，在多线程环境时，严重降低了应用程序的吞吐量。 并发类容器时专门针对并发容器设计的，使用ConcurrentHashMap来替代给予散列的传统的HashTable,而且在ConcurrentHashMap中，添加了一些常见的复合操作的支持。以及使用了CopyOnWriteArrayList替代Voctor,并发的CopyonWriteArraySet，以及并发的Queue，ConcurrentLinkedQueue和LinkedBlockingQueue，前者是高性能的队列，后者是阻塞形式的队列，具体实现Queue还有很多，例如ArrayBlockingQueue、PriorityBlockingQueue、SynchroniusQueue等 ConcurrentMapConCurrentMap接口有两个重要的实现： ConcurrentHashMap ConcurrentSkipListMap内部使用段（Segment）来表示这些不同的部分，每个段其实就是一个小的HashTable，他们有自己的锁。只要多个修改操作发生在不同的段上，他们就可以并发进行。吧把一个整体分成16段（segment）。也就是最高支持16个县城的并发修改操作。这也会在多线程场景时减小锁的粒度从而降低锁竞争的一种方案。并且代码中大多共享变量使用volatile关键字声明，目的就是第一时间获取修改的内容，性能非常好。 123456789101112131415161718192021222324252627282930package com.telinx.demo;import java.util.Iterator;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.CopyOnWriteArrayList;import java.util.concurrent.locks.ReentrantReadWriteLock;public class UseConcurrentMap &#123; public static void main(String[] args) &#123; ConcurrentHashMap&lt;String, Object&gt; chm = new ConcurrentHashMap&lt;String, Object&gt;(); chm.put("k1", "v1"); chm.put("k2", "v2"); chm.put("k3", "v3"); chm.putIfAbsent("k4", "vvvv"); // System.out.println(chm.get("k2")); // System.out.println(chm.size()); for (Map.Entry&lt;String, Object&gt; me : chm.entrySet()) &#123; System.out.println("key:" + me.getKey() + ",value:" + me.getValue()); &#125; &#125;&#125;//输出key:k4,value:vvvvkey:k3,value:v3key:k2,value:v2key:k1,value:v1 concurrentHashMap实现原理 减小锁粒度，减小锁竞争的问题，分成16个段，最多支持16个线程，大量的使用了volatile关键字 Copy-On-Write容器Copy-On-Write容器简称COW，是一种程序设计的优化策略。 JDK里的COW容器有两种：CopyOnWriteArrayList和CopyOnWriteArraySet,Cow容器非常有用，可以在非常多的并发多得并发场景中使用到。 什么是CopyOnWrite容器？ CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将容器的引用指向新的容器。这样做的好处使我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读与写不同的容器。 读多写少可以应用 12345678910111213package com.telinx.demo;import java.util.concurrent.CopyOnWriteArrayList;import java.util.concurrent.CopyOnWriteArraySet;public class UseCopyOnWrite &#123; public static void main(String[] args) &#123; CopyOnWriteArrayList&lt;String&gt; cwal = new CopyOnWriteArrayList&lt;String&gt;(); CopyOnWriteArraySet&lt;String&gt; cwas = new CopyOnWriteArraySet&lt;String&gt;(); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java并发4]]></title>
    <url>%2F2017%2F04%2F21%2F%E8%81%8A%E8%81%8AJava%E5%B9%B6%E5%8F%914%2F</url>
    <content type="text"><![CDATA[本文主要介绍了单例与多线程相结合的使用，更深刻的了解单例模式以及如何确保线程安全。 单例&amp;多线程单例模式，最常见的就是饥饿模式，和懒汉模式，一个直接实例化对象，一个在调用方法时进行实例化对象。在多个线程模式种，考虑到性能和线程安全问题，我们一般选用两种比较经典的单例模式，在性能提高的同时，又保证线程安全。 dubble check instance static inner class 饥饿模式、懒汉模式 高并发时推荐： dubble check instance / static inner class 12345678910111213141516171819package com.telinx.demo;public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; // 对获取实例的方法进行同步 if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; double check 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.telinx.demo;public class DubbleSingleton &#123; private static DubbleSingleton ds; public static DubbleSingleton getDs() &#123; if (ds == null) &#123; // 这里判断一次 try &#123; // 模拟初始化对象的准备时间... Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (DubbleSingleton.class) &#123; // 只能有一个线程实例化DubbleSingleton if (ds == null) &#123; // 这里再判断一次 ds = new DubbleSingleton(); &#125; &#125; &#125; return ds; &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(DubbleSingleton.getDs().hashCode()); &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(DubbleSingleton.getDs().hashCode()); &#125; &#125;, "t2"); Thread t3 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(DubbleSingleton.getDs().hashCode()); &#125; &#125;, "t3"); t1.start(); t2.start(); t3.start(); &#125;&#125;//输出100762919110076291911007629191 static inner class 12345678910111213package com.telinx.demo;public class InnerSingleton &#123; private static class Singletion &#123; private static Singletion single = new Singletion(); &#125; public static Singletion getInstance() &#123; return Singletion.single; &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java并发3]]></title>
    <url>%2F2017%2F04%2F18%2F%E8%81%8A%E8%81%8AJava%E5%B9%B6%E5%8F%913%2F</url>
    <content type="text"><![CDATA[本文主要介绍了线程之间的通信、使用wait/notify模拟Queue、ThreadLocal。 线程之间的通信线程通信概念：线程是操作系统中的独立个体，但这些个体如果不经过特殊的处理就不会能成为一个整体，线程间的通信就成为了整体的必用方式之一。当线程存在通信指挥，系统间的交互性会更强大，在提高CPU利用率的同时还会使开发人员对线程任务在处理的过程中进行有效的把控与监督。 使用wait / notify方法实现线程间的通信。（注意这两个方法都是object类的方法，换句话说Java为所有的对象都提供了这两个方法） wait和notify必须配合synchronized关键字使用 wait方法释放锁，notify方法不释放锁 示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.telinx.demo;//t1线程不停add,而t2线程一直判断==5，只有==5时，才把t2线程停止，这是很low的线程通信方法import java.util.ArrayList;import java.util.List;public class ListAdd1 &#123; private volatile static List list = new ArrayList(); public void add() &#123; list.add("bjsxt"); &#125; public int size() &#123; return list.size(); &#125; public static void main(String[] args) &#123; final ListAdd1 list1 = new ListAdd1(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; list1.add(); System.out.println("当前线程：" + Thread.currentThread().getName() + "添加了一个元素.."); Thread.sleep(500); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; if (list1.size() == 5) &#123; System.out.println("当前线程收到通知：" + Thread.currentThread().getName() + " list size = 5 线程停止.."); throw new RuntimeException(); &#125; &#125; &#125; &#125;, "t2"); t1.start(); t2.start(); &#125;&#125;//输出当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程收到通知：t2 list size = 5 线程停止..Exception in thread "t2" java.lang.RuntimeException at com.telinx.demo.ListAdd1$2.run(ListAdd1.java:44) at java.lang.Thread.run(Thread.java:722)当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素.. 改进，使用wait，notify改进，wait释放锁，notify不释放锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.telinx.demo;import java.util.ArrayList;import java.util.List;import java.util.concurrent.CountDownLatch;/** * @author alienware * */public class ListAdd2 &#123; private volatile static List list = new ArrayList(); public void add() &#123; list.add("bjsxt"); &#125; public int size() &#123; return list.size(); &#125; public static void main(String[] args) &#123; final ListAdd2 list2 = new ListAdd2(); final Object lock = new Object(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; synchronized (lock) &#123; System.out.println("t1启动.."); for (int i = 0; i &lt; 10; i++) &#123; list2.add(); System.out.println("当前线程：" + Thread.currentThread().getName() + "添加了一个元素.."); Thread.sleep(500); if (list2.size() == 6) &#123; System.out.println("已经发出通知.."); lock.notify(); &#125; &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (lock) &#123; System.out.println("t2启动.."); if (list2.size() != 6) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("当前线程：" + Thread.currentThread().getName() + "收到通知线程停止.."); throw new RuntimeException(); &#125; &#125; &#125;, "t2"); t2.start(); // wait释放锁 t1.start(); &#125;&#125;//输出t2启动..t1启动..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..已经发出通知..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t2收到通知线程停止..Exception in thread "t2" java.lang.RuntimeException at com.telinx.demo.ListAdd2$2.run(ListAdd2.java:62) at java.lang.Thread.run(Thread.java:722) 可以看到虽然已经发出通知，但是t2线程的异常需要等待t1执行完之后才能执行，说明wait方法释放锁，notify方法不释放锁 使用countdownLatch优化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.telinx.demo;import java.util.ArrayList;import java.util.List;import java.util.concurrent.CountDownLatch;/** * @author alienware * */public class ListAdd2 &#123; private volatile static List list = new ArrayList(); public void add() &#123; list.add("bjsxt"); &#125; public int size() &#123; return list.size(); &#125; public static void main(String[] args) &#123; final CountDownLatch countDownLatch = new CountDownLatch(1); final ListAdd2 list2 = new ListAdd2(); final Object lock = new Object(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // synchronized (lock) &#123; System.out.println("t1启动.."); for (int i = 0; i &lt; 10; i++) &#123; list2.add(); System.out.println("当前线程：" + Thread.currentThread().getName() + "添加了一个元素.."); Thread.sleep(500); if (list2.size() == 6) &#123; System.out.println("已经发出通知.."); // lock.notify(); // lock.wait(); countDownLatch.countDown(); &#125; &#125; // &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; // synchronized (lock) &#123; System.out.println("t2启动.."); if (list2.size() != 6) &#123; try &#123; // lock.wait(); countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; lock.notify(); System.out.println("当前线程：" + Thread.currentThread().getName() + "收到通知线程停止.."); throw new RuntimeException(); // &#125; &#125; &#125;, "t2"); t2.start(); t1.start(); &#125;&#125;//输出t2启动..t1启动..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..已经发出通知..当前线程：t1添加了一个元素..Exception in thread "t2" java.lang.IllegalMonitorStateException at java.lang.Object.notify(Native Method) at com.telinx.demo.ListAdd2$2.run(ListAdd2.java:66) at java.lang.Thread.run(Thread.java:722)当前线程：t1添加了一个元素..当前线程：t1添加了一个元素..当前线程：t1添加了一个元素.. 可见CountDownLatch得到的优化更符合我们所期望的情景（当某个线程到达某个时候就通知另外一个线程） 使用wait/notify模拟QueueBlockingQueue:顾名思义，首先它是一个队列，并且支持阻塞的机制，阻塞的放入和得到数据。我们要实现LinkedBloackingQueue下面两个简单的方法put和take. put:把一个Object放到BlockingQueue里，如果BlockingQueue没有空间，则调用此方法的线程被阻断，知道BlockingQueue里面有空间再继续。 take:取走BlockingQueue里面排在首位的对象，若BlockingQueue为空，阻断进入等待状态知道BlockingQueue有新的数据被加入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.telinx.demo;import java.util.LinkedList;import java.util.concurrent.atomic.AtomicInteger;public class MyQueue &#123; private final LinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;(); private final AtomicInteger count = new AtomicInteger(0); private final int maxSize; private final int minSize = 0; private final Object lock = new Object(); public MyQueue(int maxSize) &#123; this.maxSize = maxSize; &#125; public void put(Object obj) &#123; synchronized (lock) &#123; while (count.get() == maxSize) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; list.add(obj); count.getAndIncrement(); System.out.println(" 元素 " + obj + " 被添加 "); lock.notify(); &#125; &#125; public Object take() &#123; Object temp = null; synchronized (lock) &#123; while (count.get() == minSize) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; count.getAndDecrement(); temp = list.removeFirst(); System.out.println(" 元素 " + temp + " 被消费 "); lock.notify(); &#125; return temp; &#125; public int size() &#123; return count.get(); &#125; public static void main(String[] args) throws Exception &#123; final MyQueue m = new MyQueue(5); m.put("a"); m.put("b"); m.put("c"); m.put("d"); m.put("e"); System.out.println("当前元素个数：" + m.size()); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; m.put("h"); m.put("i"); &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); Object t1 = m.take(); // System.out.println("被取走的元素为：" + t1); Thread.sleep(1000); Object t2 = m.take(); // System.out.println("被取走的元素为：" + t2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "t2"); t1.start(); Thread.sleep(1000); t2.start(); &#125;&#125;//输出元素 a 被添加 元素 b 被添加 元素 c 被添加 元素 d 被添加 元素 e 被添加 当前元素个数：5 元素 a 被消费 元素 h 被添加 元素 b 被消费 元素 i 被添加 ThreadLocalThreadLoacal概念：线程局部变量，是一种多线程间并发访问变量的解决方案。与其synchronized等加锁的方式不同，ThreadLocal完全不提供锁，而使用以空间换时间的手段，为每个线程提供变量的独立副本，以保障线程安全。 从性能上说，ThreadLocal不具有绝对的优势，在并发并不是很高的时候，加锁的性能会更好，但作为一套与锁完全无关的线程安全解决方案，在高并发量或者竞争激烈的场景，使用ThreadLocal可以在一定程度上减少锁的竞争。 ThreadLocalMa中的key为当前线程value为线程所需要的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.telinx.demo;public class ConnThreadLocal &#123; public static ThreadLocal&lt;String&gt; th = new ThreadLocal&lt;String&gt;(); public void setTh(String value) &#123; th.set(value); &#125; public void getTh() &#123; System.out.println(Thread.currentThread().getName() + ":" + this.th.get()); &#125; public static void main(String[] args) throws InterruptedException &#123; final ConnThreadLocal ct = new ConnThreadLocal(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; ct.setTh("张三"); ct.getTh(); &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); // ct.setTh("李四"); ct.getTh(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "t2"); t1.start(); t2.start(); &#125;&#125;//输出//输出t1:张三t2:null// ct.setTh("李四");放开，输出 t1:张三t2:李四可以得知，t2线程只能拿到自己线程放入值public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java并发2]]></title>
    <url>%2F2017%2F04%2F17%2F%E8%81%8A%E8%81%8AJava%E5%B9%B6%E5%8F%912%2F</url>
    <content type="text"><![CDATA[本文通过示例让读者进一步掌握syncheronized、volatile。 synchronized代码块使用synchronized声明的方法在某些情况下是有弊端的，比如A线程调用同步的方法执行一个很长时间的任务，那么B线程就必须等待比较长的时间才能执行，这样的情况可以使用synchronized代码块去优化执行时间，也就是通常所说的减小锁的粒度。 示例如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.telinx.concurrency;/** * 使用synchronized代码块减小锁的粒度，提高性能 * * @author alienware * */public class Optimize &#123; public void doLongTimeTask() &#123; try &#123; System.out.println("当前线程开始：" + Thread.currentThread().getName() + ", 正在执行一个较长时间的业务操作，其内容不需要同步"); Thread.sleep(2000); synchronized (this) &#123; System.out.println("当前线程：" + Thread.currentThread().getName() + ", 执行同步代码块，对其同步变量进行操作"); Thread.sleep(1000); &#125; System.out.println("当前线程结束：" + Thread.currentThread().getName() + ", 执行完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; final Optimize otz = new Optimize(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; otz.doLongTimeTask(); &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; otz.doLongTimeTask(); &#125; &#125;, "t2"); t1.start(); t2.start(); &#125;&#125;当前线程开始：t1, 正在执行一个较长时间的业务操作，其内容不需要同步当前线程开始：t2, 正在执行一个较长时间的业务操作，其内容不需要同步当前线程：t2, 执行同步代码块，对其同步变量进行操作当前线程结束：t2, 执行完毕当前线程：t1, 执行同步代码块，对其同步变量进行操作当前线程结束：t1, 执行完毕 synchronized可以使用任意的Object进行加锁，用法比较灵活 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.telinx.concurrency;/** * 使用synchronized代码块加锁,比较灵活 * * @author alienware * */public class ObjectLock &#123; public void method1() &#123; synchronized (this) &#123; // 对象锁 try &#123; System.out.println("do method1.."); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void method2() &#123; // 类锁 synchronized (ObjectLock.class) &#123; try &#123; System.out.println("do method2.."); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private Object lock = new Object(); public void method3() &#123; // 任何对象锁 synchronized (lock) &#123; try &#123; System.out.println("do method3.."); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; final ObjectLock objLock = new ObjectLock(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; objLock.method1(); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; objLock.method2(); &#125; &#125;); Thread t3 = new Thread(new Runnable() &#123; @Override public void run() &#123; objLock.method3(); &#125; &#125;); t1.start(); t2.start(); t3.start(); &#125;&#125;do method2..do method3..do method1.. 另外特别注意一个问题，就是不用使用String的常量加锁，会出现死循环问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.telinx.concurrency;/** * synchronized代码块对字符串的锁，注意String常量池的缓存功能 * * @author alienware * */public class StringLock &#123; public void method() &#123; // new String("字符串常量") synchronized ("字符串常量") &#123; try &#123; while (true) &#123; System.out.println("当前线程 : " + Thread.currentThread().getName() + "开始"); Thread.sleep(1000); System.out.println("当前线程 : " + Thread.currentThread().getName() + "结束"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; final StringLock stringLock = new StringLock(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; stringLock.method(); &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; stringLock.method(); &#125; &#125;, "t2"); t1.start(); t2.start(); &#125;&#125;当前线程 : t1开始当前线程 : t1结束当前线程 : t1开始当前线程 : t1结束当前线程 : t1开始当前线程 : t1结束... 锁对象的改变问题，当使用一个对象进行加锁的时候，要注意对象本身发生改变的时候，那么持有的锁就不同。如果对象本事不发生改变，那么依然是同步的，即使是对象的属性发生了改变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.telinx.concurrency;/** * 同一对象属性的修改不会影响锁的情况 * * @author alienware * */public class ModifyLock &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public synchronized void changeAttributte(String name, int age) &#123; try &#123; System.out.println("当前线程 : " + Thread.currentThread().getName() + " 开始"); this.setName(name); this.setAge(age); System.out.println("当前线程 : " + Thread.currentThread().getName() + " 修改对象内容为： " + this.getName() + ", " + this.getAge()); Thread.sleep(2000); System.out.println("当前线程 : " + Thread.currentThread().getName() + " 结束"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; final ModifyLock modifyLock = new ModifyLock(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; modifyLock.changeAttributte("张三", 20); &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; modifyLock.changeAttributte("李四", 21); &#125; &#125;, "t2"); t1.start(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t2.start(); &#125;&#125;//输出当前线程 : t1 开始当前线程 : t1 修改对象内容为： 张三, 20当前线程 : t1 结束当前线程 : t2 开始当前线程 : t2 修改对象内容为： 李四, 21当前线程 : t2 结束 死锁的问题，示例如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.telinx.concurrency;/** * 死锁问题，在设计程序时就应该避免双方相互持有对方的锁的情况 * * @author alienware * */public class DeadLock implements Runnable &#123; private String tag; private static Object lock1 = new Object(); private static Object lock2 = new Object(); public void setTag(String tag) &#123; this.tag = tag; &#125; @Override public void run() &#123; if (tag.equals("a")) &#123; synchronized (lock1) &#123; try &#123; System.out.println("当前线程 : " + Thread.currentThread().getName() + " 进入lock1执行"); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock2) &#123; System.out.println("当前线程 : " + Thread.currentThread().getName() + " 进入lock2执行"); &#125; &#125; &#125; if (tag.equals("b")) &#123; synchronized (lock2) &#123; try &#123; System.out.println("当前线程 : " + Thread.currentThread().getName() + " 进入lock2执行"); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock1) &#123; System.out.println("当前线程 : " + Thread.currentThread().getName() + " 进入lock1执行"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; DeadLock d1 = new DeadLock(); d1.setTag("a"); DeadLock d2 = new DeadLock(); d2.setTag("b"); Thread t1 = new Thread(d1, "t1"); Thread t2 = new Thread(d2, "t2"); t1.start(); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t2.start(); &#125;&#125;//输出当前线程 : t1 进入lock1执行当前线程 : t2 进入lock2执行》线程死在这里不停止运行，也不输出 volatile关键字的概念volatile关键字的概念：volatile关键字的主要作用是使变量在多个线程可见 1234567891011121314151617181920212223242526272829303132333435package com.telinx.concurrency;public class RunThread extends Thread &#123; private volatile boolean isRunning = true; private void setRunning(boolean isRunning) &#123; this.isRunning = isRunning; &#125; public void run() &#123; System.out.println("进入run方法.."); int i = 0; while (isRunning == true) &#123; // .. &#125; System.out.println("线程停止"); &#125; public static void main(String[] args) throws InterruptedException &#123; RunThread rt = new RunThread(); rt.start(); Thread.sleep(1000); rt.setRunning(false); System.out.println("isRunning的值已经被设置了false"); &#125;&#125;//输出进入run方法..isRunning的值已经被设置了false线程停止如果将volatile去了，那么rt.setRunning(false);是不起任何作用的，程序不会结束，这里涉及volatile保证始终读取的是一块内存区域的值，而不是存在值复制开辟新的栈空间 示例总结： 在Java中，每一个线程都会有一块工作内存区，其中存放着所有线程共享的主内存中的变量值的拷贝。当线程执行时，它在自己的工作内存区中操作这些变量。为了存取一个共享的变量，一个线程通常先获取锁定并去清除它的内存工作区，把这些共享变量从所有线程的共享内存中正确的装入到他自己的所在的工作内存区中，当线程解锁时保证该工作内存区中变量的值协会到共享内存中。 一个线程可以执行的操作有使用（use）,赋值（assign）、装载（load）、存储(store)、锁定(lock)、解锁(unlock)。 而主内存可以执行的操作有读(read)、写(write)、锁定(lock)、解锁(unlock)，每个操作都是原子的。 volatile的作用就是强制线程到主内存（共享内存）里去读取变量，而不去线程工作内存区里去读取，从而实现了多个线程的变量可见。也就是满足线程安全的可见性，也只是可见性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.telinx.demo;import java.util.concurrent.atomic.AtomicInteger;/** * volatile关键字不具备synchronized关键字的原子性（同步） * * @author alienware * */public class VolatileNoAtomic extends Thread &#123; // private static volatile int count; private static AtomicInteger count = new AtomicInteger(0); private static void addCount() &#123; for (int i = 0; i &lt; 1000; i++) &#123; // count++ ; count.incrementAndGet(); &#125; System.out.println(count); &#125; public void run() &#123; addCount(); &#125; public static void main(String[] args) &#123; VolatileNoAtomic[] arr = new VolatileNoAtomic[100]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = new VolatileNoAtomic(); &#125; for (int i = 0; i &lt; 10; i++) &#123; arr[i].start(); &#125; &#125;&#125;//输出16853315216240005022743279248693900010000 volatile关键字的非原子性volatile关键字虽然拥有多个线程之间的可见性，但是不具备同步性（也就是原子性），可以算一个轻量级的synchronized，性能要比synchronized强很多，不会造成阻塞（在很多开源的架构中，比如netty的底层代码就大量使用了volatile，可见netty性能一定会非常不错的）。这里需要注意，一般volatile用于多个线程可见的变量操作，并不能代替synchronized的同步功能（通过上述VolatileNoAtomic就可以发现） 示例总结：volatile关键字只具有可见性，没有原子性，要实现原子性建议使用atomic类的系列对象，支持原子性操作（注意atomic类只保证本身方法的原子性，并不保证多次操作的原子性） 1234比较：①volatile轻量级，只能修饰变量。synchronized重量级，还可修饰方法②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。synchronized不仅保证可见性，而且还保证原子性]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java并发1]]></title>
    <url>%2F2017%2F04%2F15%2F%E8%81%8A%E8%81%8AJava%E5%B9%B6%E5%8F%911%2F</url>
    <content type="text"><![CDATA[为什么学并发编程？什么是线程安全？什么是对象锁的同步？什么是对象锁的异步？什么是脏读？以及syncheronized的概念是什么？ 为什么学并发编程我们为什么要去学习并发编程？ 面试非常重要，企业面试程序员的标准，考察因素： 考法公司技术你是否熟悉50%以上，或者我们公司有特殊的技术需求，正好你熟悉，那么可能会优先考虑录用你。 细节、态度、人品（前两条瞒住基本就会录用你） 知识面，潜力（这是加分项） 对自己的技术提升很有帮助 也是我们最受益的一点，就是编发变成技术你学到手了，有了一个知识面的扩展，眼界更宽了。 如果你学习好了并发编程，在以后的分布式系统中，你都可以找到类似的并发、分布式、并行处理的概念 我们该如何学习并发编程： 在公司里其实很多的JAVA程序员，亦或是所有的技术Leader，他们可能知道多线程有syncheronized、volatile、ReentrantLock、concurrent下数据包等等…这些看似高深的代名词，但是不等于他们就会懂得如何使用，滥用的结果往往需要自己承担的相应的后果。其实并发编程没有我们想象的那么复杂，我们只需要掌握最基本的概念就可以轻松的入门，然后从中剖析这些概念的本质，结合实际业务去应用，那么就可以成为并发编程方法的熟练者。 线程安全线程安全的概念：当多个线程访问某一个类（对象或方法）时，这个类始终都能表现出正确的行为（不会出现不确定的结果），那么这个类（对象或方法）就是线程安全的。 synchronized:可以在任意对象及方法上加锁，而加锁的这段代码称之为“互斥区”或“临界区” 示例：MyThread 示例总结：当多个线程访问myTread的run方法时，以排队的方法进行处理（这里排队时按照CPU分配的先后顺序而定的），一个线程想要执行synchronized修饰的方法里的代码，首先是尝试获得所，如果拿到锁，执行synchronied代码体内容；拿不到锁，这个线程就会不断的尝试获得这把锁直到道拿到为止，而且十多个线程同时去经这个这把锁（也就是会有锁竞争的问题） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 线程安全概念：当多个线程访问某一个类（对象或方法）时，这个对象始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。 * synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为"互斥区"或"临界区" * * @author alienware * */public class MyThread extends Thread &#123; private int count = 5; // synchronized加锁 public /* synchronized */ void run() &#123; count--; System.out.println(this.currentThread().getName() + " count = " + count); &#125; public static void main(String[] args) &#123; /** * 分析：当多个线程访问myThread的run方法时，以排队的方式进行处理（这里排对是按照CPU分配的先后顺序而定的）， * 一个线程想要执行synchronized修饰的方法里的代码： 1 尝试获得锁 2 * 如果拿到锁，执行synchronized代码体内容；拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止， * 而且是多个线程同时去竞争这把锁。（也就是会有锁竞争的问题） */ MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread, "t1"); Thread t2 = new Thread(myThread, "t2"); Thread t3 = new Thread(myThread, "t3"); Thread t4 = new Thread(myThread, "t4"); Thread t5 = new Thread(myThread, "t5"); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); &#125;&#125;//run方法加synchronized，有序输出t1 count = 4t4 count = 3t5 count = 2t3 count = 1t2 count = 0//run方法不加synchronized，无序输出t1 count = 3t5 count = 1t3 count = 2t2 count = 3t4 count = 0 多个线程多个锁多个线程多个锁：多个线程，每个线程都可以拿到自己的指定的锁，分别获得锁之后，执行synchronized方法图的内容 示例：MultiThread 示例总结：关键字synchronized取得的锁都是对象锁，而不是把一段代码（方法）当做锁，所以示例代码中那个线程先执行synchronized关键字的方法，那个线程就持有持有该刚方法所属对象的锁(Lock)，两个对象，线程获得的就是两个不同的锁，他们互不影响。 有一种情况则是相同的锁，即在静态方法上加synchronized关键字，表示锁定.class类，类一级别的锁（独占.class锁）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 关键字synchronized取得的锁都是对象锁，而不是把一段代码（方法）当做锁， * 所以代码中哪个线程先执行synchronized关键字的方法，哪个线程就持有该方法所属对象的锁（Lock）， * * 在静态方法上加synchronized关键字，表示锁定.class类，类一级别的锁（独占.class类）。 * * @author alienware * */public class MultiThread &#123; private int num = 0; /** static */ public synchronized void printNum(String tag) &#123; try &#123; if (tag.equals("a")) &#123; num = 100; System.out.println("tag a, set num over!"); Thread.sleep(1000); &#125; else &#123; num = 200; System.out.println("tag b, set num over!"); &#125; System.out.println("tag " + tag + ", num = " + num); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 注意观察run方法输出顺序 public static void main(String[] args) &#123; // 俩个不同的对象 final MultiThread m1 = new MultiThread(); final MultiThread m2 = new MultiThread(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; m1.printNum("a"); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; m2.printNum("b"); &#125; &#125;); t1.start(); t2.start(); &#125;&#125;//printNum加static时，为该类Class类锁，线程a、b有序执行tag a, set num over!tag a, num = 100tag b, set num over!tag b, num = 200//printNum不加static时，为该类Class对象锁，线程a、b无序执行tag a, set num over!tag b, set num over!tag b, num = 200tag a, num = 100 对象锁的同步与异步同步：synchronized 同步的概念就是共享，我们要牢牢记住“共享”这两个字，如果不是共享的资源，就没有必要进行同步。 异步：asynchronized 异步的概念就是独立，互相之间不受到任何的制约。就好像是哦们学习http的时候，在页面发起Ajax请求，我们还有继续浏览或者操作页面的内容，二者之间没有任何的关系。 同步的目的是为了线程安全，其实对于线程安全来说，需要满足两个特性： 原子性（同步） 可见性，示例如下 示例总结： A线程现持有object对象的Lock锁，B线程如果在这个时候调用对象中的同步（synchronized）方法则需要等待，也就是同步 A线程现持有object对象的Lock锁，B线程可以以异步的方式调用对象中的非synchronized修饰的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.telinx.concurrency;/** * 对象锁的同步和异步问题 * * @author alienware * */public class MyObject &#123; public synchronized void method1() &#123; try &#123; System.out.println(Thread.currentThread().getName()); Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** synchronized */ public synchronized void method2() &#123; System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; final MyObject mo = new MyObject(); /** * 分析： t1线程先持有object对象的Lock锁，t2线程可以以异步的方式调用对象中的非synchronized修饰的方法 * t1线程先持有object对象的Lock锁，t2线程如果在这个时候调用对象中的同步（synchronized）方法则需等待，也就是同步 */ Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method1(); &#125; &#125;, "t1"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method2(); &#125; &#125;, "t2"); t1.start(); t2.start(); &#125;&#125;//method2不加synchronized 同时输出 t1 t2//method2加synchronized 先输出t1,4秒后输出t2 脏读对于对象的同步和异步的方法，我们在设计自己的程序的时候，一定要考虑问题的整体，不然那就会出现数据不一致的错误，很经典的错误就是脏读（dirty read） 示例总结：在我们对一个对象的方法加锁的时候，需要考虑业务的整体性，即为setValue/getValue方法同时加锁synchronized同步关键字，保证业务（service）的原子性，不然会出现业务错误（也从侧面保证业务的一致性） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.telinx.concurrency;/** * 业务整体需要使用完整的synchronized，保持业务的原子性。 * * @author alienware * */public class DirtyRead &#123; private String username = "bjsxt"; private String password = "123"; public synchronized void setValue(String username, String password) &#123; this.username = username; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.password = password; System.out.println("setValue最终结果：username = " + username + " , password = " + password); &#125; public /* synchronized */ void getValue() &#123; System.out.println("getValue方法得到：username = " + this.username + " , password = " + this.password); &#125; public static void main(String[] args) throws Exception &#123; final DirtyRead dr = new DirtyRead(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; dr.setValue("z3", "456"); &#125; &#125;); t1.start(); Thread.sleep(1000); dr.getValue(); &#125;&#125;//getValue加锁，等待setValue执行完，输出setValue最终结果：username = z3 , password = 456getValue方法得到：username = z3 , password = 456//getValue不加锁，不等待setValue执行完，输出getValue方法得到：username = z3 , password = 123setValue最终结果：username = z3 , password = 456 synchronized其他概念synchronized锁重入: 关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个此案城得到一个对象的锁后，再次请求此对象是可以再次得到该对象的锁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * synchronized的重入 * * @author alienware * */public class SyncDubbo2 &#123; static class Main &#123; public int i = 10; public synchronized void operationSup() &#123; try &#123; i--; System.out.println(&quot;Main print i = &quot; + i); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class Sub extends Main &#123; public synchronized void operationSub() &#123; try &#123; while (i &gt; 0) &#123; i--; System.out.println(&quot;Sub print i = &quot; + i); Thread.sleep(100); this.operationSup(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; Sub sub = new Sub(); sub.operationSub(); &#125; &#125;); t1.start(); &#125;&#125;//输出Sub print i = 9Main print i = 8Sub print i = 7Main print i = 6Sub print i = 5Main print i = 4Sub print i = 3Main print i = 2Sub print i = 1Main print i = 0 出现异常，锁自动释放: 说明，对于web应用程序，异常释放锁的情况，如果不及时处理，很可能对你的应用程序业务逻辑产品严重的错误，比如你现在执行一个队列任务，很多对象都去在等待第一个对象正确的执行完毕后释放锁，但是第一个对象由于异常的出现，导致业务逻辑没有正常的执行完毕，就释放了锁，那么可想而知后续的对象执行的都是错误的逻辑，所以这一点一定要一起呢注意，在编写代码的时候，一定要考虑周全。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * synchronized异常 * * @author alienware * */public class SyncException &#123; private int i = 0; public synchronized void operation() &#123; while (true) &#123; try &#123; i++; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + &quot; , i = &quot; + i); if (i == 20) &#123; // Integer.parseInt(&quot;a&quot;); throw new RuntimeException(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; final SyncException se = new SyncException(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; se.operation(); &#125; &#125;, &quot;t1&quot;); t1.start(); &#125;&#125;t1 , i = 1t1 , i = 2t1 , i = 3t1 , i = 4t1 , i = 5t1 , i = 6t1 , i = 7t1 , i = 8t1 , i = 9t1 , i = 10t1 , i = 11t1 , i = 12t1 , i = 13t1 , i = 14t1 , i = 15t1 , i = 16t1 , i = 17t1 , i = 18t1 , i = 19t1 , i = 20Exception in thread &quot;t1&quot; java.lang.RuntimeException at com.telinx.concurrency.SyncException.operation(SyncException.java:21) at com.telinx.concurrency.SyncException$1.run(SyncException.java:35) at java.lang.Thread.run(Thread.java:722)]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊SQL——内查询示例2]]></title>
    <url>%2F2017%2F04%2F05%2F%E8%81%8A%E8%81%8ASQL%E2%80%94%E2%80%94%E5%86%85%E6%9F%A5%E8%AF%A2%E7%A4%BA%E4%BE%8B2%2F</url>
    <content type="text"><![CDATA[本文通过一个实例介绍SQL内连接查询。 建表12345CREATE TABLE `val_data` ( `id` bigint(10) NOT NULL AUTO_INCREMENT, `cnt` int(8) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 数据 id cnt 1 10000 2 5000 3 3000 4 1500 5 600 7 200 须统计数据 id cnt rate rate1 1 10000 1 2 5000 0.5 0.5 3 3000 0.3 0.6 4 1500 0.15 0.5 5 600 0.6 0.4 6 200 0.2 0.333 SQL查询123456789101112SELECT X.id, X.cnt, X.rate, X.cnt/Y.cnt as rate1FROM( SELECT A.id, A.cnt, A.cnt/B.cnt AS rate FROM val_data A INNER JOIN val_data B WHERE B.id =1) XLEFT JOIN val_data Y ON X.id-1=Y.id]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊SQL——SQL练习案例]]></title>
    <url>%2F2017%2F04%2F04%2F%E8%81%8A%E8%81%8ASQL%E2%80%94%E2%80%94SQL%E7%BB%83%E4%B9%A0%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[本文详细的分析了常用SQL查询案例，熟悉以下SQL，基本可以胜任大部分SQL工作。 Student(StudentId,Sname,Sage,Ssex) 学生表 StudentId：学号:Sname：学生姓名；Sage：学生年龄；Ssex：学生性别 Course(CourseId,Cname,TeacherId) 课程表 CourseId,课程编号；Cname：课程名字；TeacherId：教师编号 SC(StudentId,CourseId,score) 成绩表 StudentId：学号；CourseId,课程编号；score：成绩 Teacher(TeacherId,Tname) 教师表 TeacherId：教师编号； Tname：教师名字 问题： 查询“001”课程比“002”课程成绩高的所有学生的学号； 1234select a.StudentId from (select StudentId,score from SC where CourseId='001') a,(select StudentId,scorefrom SC where CourseId='002') bwhere a.score&gt;b.score and a.StudentId=b.StudentId; ​ 查询平均成绩大于60分的同学的学号和平均成绩； 123select StudentId,avg(score)from scgroup by StudentId having avg(score) &gt;60; ​ 查询所有同学的学号、姓名、选课数、总成绩； 123select Student.StudentId,Student.Sname,count(SC.CourseId),sum(score)from Student left Outer join SC on Student.StudentId=SC.StudentIdgroup by Student.StudentId,Sname 查询姓“李”的老师的个数； 123select count(distinct(Tname))from Teacherwhere Tname like '李%'; 查询没学过“叶平”老师课的同学的学号、姓名； 1234select Student.StudentId,Student.Snamefrom Student where StudentId not in (select distinct( SC.StudentId) from SC,Course,Teacher where SC.CourseId=Course.CourseId and Teacher.TeacherId=Course.TeacherId and Teacher.Tname='叶平'); ​ 查询学过“001”并且也学过编号“002”课程的同学的学号、姓名； 123select Student.StudentId,Student.Sname from Student,SC where Student.StudentId=SC.StudentId and SC.CourseId='001'and exists( Select * from SC as SC2 where SC2.StudentId=SC.StudentId and SC_2.CourseId='002'); ​ 查询学过“叶平”老师所教的所有课的同学的学号、姓名； 123456select StudentId,Snamefrom Studentwhere StudentId in (select StudentId from SC ,Course ,Teacher where SC.CourseId=Course.CourseId and Teacher.TeacherId=Course.TeacherId and Teacher.Tname='叶平' group by StudentId having count(SC.CourseId)=(select count(CourseId) from Course,Teacher where Teacher.TeacherId=Course.TeacherId and Tname='叶平')); 查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名； 123Select StudentId,Sname from (select Student.StudentId,Student.Sname,score ,(select score from SC SC2 where SC2.StudentId=Student.StudentId and SC_2.CourseId='002') score2from Student,SC where Student.StudentId=SC.StudentId and CourseId='001') S_2 where score2 &lt;score; ​ 查询所有课程成绩小于60分的同学的学号、姓名； 1234select StudentId,Snamefrom Studentwhere StudentId not in (select Student.StudentId from Student,SC where S.StudentId=SC.StudentId and score&gt;60); ​ 查询没有学全所有课的同学的学号、姓名； 12345select Student.StudentId,Student.Snamefrom Student,SCwhere Student.StudentId=SC.StudentId group by Student.StudentId,Student.Sname having count(CourseId) &lt;(select count(CourseId) from Course); 查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名； 123select StudentId,Sname from Student,SC where Student.StudentId=SC.StudentId and CourseId in select CourseId from SC where StudentId='1001'; 查询至少学过学号为“001”同学所有一门课的其他同学学号和姓名； 1234select distinct SC.StudentId,Snamefrom Student,SCwhere Student.StudentId=SC.StudentId and CourseId in (select CourseId from SC where StudentId='001'); 把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩； 123update SC set score=(select avg(SC_2.score) from SC SC_2where SC_2.CourseId=SC.CourseId ) from Course,Teacher where Course.CourseId=SC.CourseId and Course.TeacherId=Teacher.TeacherId and Teacher.Tname='叶平'); 查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名； 1234select StudentId from SC where CourseId in (select CourseId from SC where StudentId='1002')group by StudentId having count()=(select count() from SC where StudentId='1002'); ​ 删除学习“叶平”老师课的SC表记录； 123Delect SCfrom course ,Teacher where Course.CourseId=SC.CourseId and Course.TeacherId= Teacher.TeacherId and Tname='叶平'; ​ 向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、2、号课的平均成绩； 12Insert SC select StudentId,'002',(Select avg(score)from SC where CourseId='002') from Student where StudentId not in (Select StudentId from SC where CourseId='002'); 按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示： 学生ID,,数据库,企业管理,英语,有效课程数,有效平均分​ 123456789SELECT StudentId as 学生ID,(SELECT score FROM SC WHERE SC.StudentId=t.StudentId AND CourseId='004') AS 数据库,(SELECT score FROM SC WHERE SC.StudentId=t.StudentId AND CourseId='001') AS 企业管理,(SELECT score FROM SC WHERE SC.StudentId=t.StudentId AND CourseId='006') AS 英语,COUNT(*) AS 有效课程数, AVG(t.score) AS 平均成绩FROM SC AS tGROUP BY StudentIdORDER BY avg(t.score) 查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分​ 12345678910111213SELECT L.CourseId As 课程ID,L.score AS 最高分,R.score AS 最低分FROM SC L ,SC AS RWHERE L.CourseId = R.CourseId andL.score = (SELECT MAX(IL.score) FROM SC AS IL,Student AS IM WHERE L.CourseId = IL.CourseId and IM.StudentId=IL.StudentId GROUP BY IL.CourseId)ANDR.Score = (SELECT MIN(IR.score) FROM SC AS IR WHERE R.CourseId = IR.CourseId GROUP BY IR.CourseId ); 按各科平均成绩从低到高和及格率的百分数从高到低顺序​ 123456789SELECT t.CourseId AS 课程号,max(course.Cname)AS 课程名,isnull(AVG(score),0) AS 平均成绩,100 * SUM(CASE WHEN isnull(score,0)&gt;=60 THEN 1 ELSE 0 END)/COUNT(*) AS 及格百分数FROM SC T,Coursewhere t.CourseId=course.CourseIdGROUP BY t.CourseIdORDER BY 100 * SUM(CASE WHEN isnull(score,0)&gt;=60 THEN 1 ELSE 0 END)/COUNT(*) DESC 查询如下课程平均成绩和及格率的百分数(用”1行”显示): 企业管理（001），马克思（002），OO&amp;UML （003），数据库（004）​ 12345678910SELECT SUM(CASE WHEN CourseId ='001' THEN score ELSE 0 END)/SUM(CASE CourseId WHEN '001' THEN 1 ELSE 0 END) AS 企业管理平均分,100 * SUM(CASE WHEN CourseId = '001' AND score &gt;= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CourseId = '001' THEN 1 ELSE 0 END) AS 企业管理及格百分数,SUM(CASE WHEN CourseId = '002' THEN score ELSE 0 END)/SUM(CASE CourseId WHEN '002' THEN 1 ELSE 0 END) AS 马克思平均分,100 * SUM(CASE WHEN CourseId = '002' AND score &gt;= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CourseId = '002' THEN 1 ELSE 0 END) AS 马克思及格百分数,SUM(CASE WHEN CourseId = '003' THEN score ELSE 0 END)/SUM(CASE CourseId WHEN '003' THEN 1 ELSE 0 END) AS UML平均分,100 * SUM(CASE WHEN CourseId = '003' AND score &gt;= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CourseId = '003' THEN 1 ELSE 0 END) AS UML及格百分数,SUM(CASE WHEN CourseId = '004' THEN score ELSE 0 END)/SUM(CASE CourseId WHEN '004' THEN 1 ELSE 0 END) AS 数据库平均分,100 * SUM(CASE WHEN CourseId = '004' AND score &gt;= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CourseId = '004' THEN 1 ELSE 0 END) AS 数据库及格百分数 FROM SC 查询不同老师所教不同课程平均分从高到低显示 12345678910SELECT max(Z.TeacherId) AS 教师ID, MAX(Z.Tname) AS 教师姓名, C.CourseId AS 课程ＩＤ, MAX(C.Cname) AS 课程名称, AVG(Score) AS 平均成绩 FROM SC AS T,Course AS C ,Teacher AS Z where T.CourseId=C.CourseId and C.TeacherId=Z.TeacherIdGROUP BY C.CourseIdORDER BY AVG(Score) DESC ​ 查询如下课程成绩第 3 名到第 6 名的学生成绩单：企业管理（001），马克思（002），UML （003），数据库（004）[学生ID],[学生姓名],企业管理,马克思,UML,数据库,平均成绩​ 12345678910111213141516171819202122232425SELECT DISTINCT top 3 SC.StudentId As 学生学号, Student.Sname AS 学生姓名 , T1.score AS 企业管理, T2.score AS 马克思, T3.score AS UML, T4.score AS 数据库, ISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0) as 总分FROM Student,SC LEFT JOIN SC AS T1 ON SC.StudentId = T1.StudentId AND T1.CourseId = '001'LEFT JOIN SC AS T2 ON SC.StudentId = T2.StudentId AND T2.CourseId = '002'LEFT JOIN SC AS T3 ON SC.StudentId = T3.StudentId AND T3.CourseId = '003'LEFT JOIN SC AS T4 ON SC.StudentId = T4.StudentId AND T4.CourseId = '004'WHERE student.StudentId=SC.StudentId andISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0)NOT IN(SELECT DISTINCT TOP 15 WITH TIES ISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0) FROM sc LEFT JOIN sc AS T1 ON sc.StudentId = T1.StudentId AND T1.CourseId = 'k1' LEFT JOIN sc AS T2 ON sc.StudentId = T2.StudentId AND T2.CourseId = 'k2' LEFT JOIN sc AS T3 ON sc.StudentId = T3.StudentId AND T3.CourseId = 'k3' LEFT JOIN sc AS T4 ON sc.StudentId = T4.StudentId AND T4.CourseId = 'k4' ORDER BY ISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0) DESC); 统计列印各科成绩,各分数段人数:课程ID,课程名称,[100-85],[85-70],[70-60],[ &lt;60]​ 12345678910SELECT SC.CourseId as 课程ID, Cname as 课程名称, SUM(CASE WHEN score BETWEEN 85 AND 100 THEN 1 ELSE 0 END) AS [100 - 85], SUM(CASE WHEN score BETWEEN 70 AND 85 THEN 1 ELSE 0 END) AS [85 - 70], SUM(CASE WHEN score BETWEEN 60 AND 70 THEN 1 ELSE 0 END) AS [70 - 60], SUM(CASE WHEN score &lt; 60 THEN 1 ELSE 0 END) AS [60 -]FROM SC,Coursewhere SC.CourseId=Course.CourseIdGROUP BY SC.CourseId,Cname; ​ 查询学生平均成绩及其名次 ​ 123456789101112SELECT 1+(SELECT COUNT( distinct 平均成绩) FROM (SELECT StudentId,AVG(score) AS 平均成绩 FROM SC GROUP BY StudentId ) AS T1 WHERE 平均成绩 &gt; T2.平均成绩) as 名次, StudentId as 学生学号,平均成绩 FROM (SELECT StudentId,AVG(score) 平均成绩 FROM SC GROUP BY StudentId ) AS T2 ORDER BY 平均成绩 desc; ​ 查询各科成绩前三名的记录:(不考虑成绩并列情况) ​ 12345678SELECT t1.StudentId as 学生ID,t1.CourseId as 课程ID,Score as 分数FROM SC t1WHERE score IN (SELECT TOP 3 score FROM SC WHERE t1.CourseId= CourseId ORDER BY score DESC )ORDER BY t1.CourseId; 查询每门课程被选修的学生数 1select CourseId,count(StudentId) from sc group by CourseId; 查询出只选修了一门课程的全部学生的学号和姓名 123select SC.StudentId,Student.Sname,count(CourseId) AS 选课数from SC ,Studentwhere SC.StudentId=Student.StudentId group by SC.StudentId ,Student.Sname having count(CourseId)=1; 查询男生、女生人数 12Select count(Ssex) as 男生人数 from Student group by Ssex having Ssex='男';Select count(Ssex) as 女生人数 from Student group by Ssex having Ssex='女'； 查询姓“张”的学生名单 1SELECT Sname FROM Student WHERE Sname like '张%'; 查询同名同性学生名单，并统计同名人数 1select Sname,count() from Student group by Sname having count()&gt;1; 1981年出生的学生名单(注：Student表中Sage列的类型是datetime) 123select Sname, CONVERT(char (11),DATEPART(year,Sage)) as agefrom studentwhere CONVERT(char(11),DATEPART(year,Sage))='1981'; ​ 查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列 1Select CourseId,Avg(score) from SC group by CourseId order by Avg(score),CourseId DESC ; 查询平均成绩大于85的所有学生的学号、姓名和平均成绩 123select Sname,SC.StudentId ,avg(score)from Student,SCwhere Student.StudentId=SC.StudentId group by SC.StudentId,Sname having avg(score)&gt;85; 查询课程名称为“数据库”，且分数低于60的学生姓名和分数 123456Select Sname,isnull(score,0)from Student,SC,Coursewhere SC.StudentId=Student.StudentId and SC.CourseId=Course.CourseId and Course.Cname='数据库'and score &lt;60; 查询所有学生的选课情况； 123SELECT SC.StudentId,SC.CourseId,Sname,CnameFROM SC,Student,Coursewhere SC.StudentId=Student.StudentId and SC.CourseId=Course.CourseId ; 查询任何一门课程成绩在70分以上的姓名、课程名称和分数； 123SELECT distinct student.StudentId,student.Sname,SC.CourseId,SC.scoreFROM student,ScWHERE SC.score&gt;=70 AND SC.StudentId=student.StudentId; 查询不及格的课程，并按课程号从大到小排列 1select CourseId from sc where scor e &lt;60 order by CourseId ; 查询课程编号为003且课程成绩在80分以上的学生的学号和姓名； 12select SC.StudentId,Student.Sname from SC,Student where SC.StudentId=Student.StudentId and Score&gt;80 and CourseId='003'; 求选了课程的学生人数 1select count(*) from sc; 查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩 1234567select Student.Sname,scorefrom Student,SC,Course C,Teacherwhere Student.StudentId=SC.StudentId and SC.CourseId=C.CourseId and C.TeacherId=Teacher.TeacherId and Teacher.Tname='叶平' and SC.score=(select max(score)from SC where CourseId=C.CourseId ); 查询各个课程及相应的选修人数 1select count(*) from sc group by CourseId; 查询不同课程成绩相同的学生的学号、课程号、学生成绩 123select distinct A.StudentId,B.score from SC A ,SC B where A.Score=B.Score and A.CourseId &lt;&gt;B.CourseId ; 查询每门功成绩最好的前两名​ 12345678SELECT t1.StudentId as 学生ID,t1.CourseId as 课程ID,Score as 分数 FROM SC t1 WHERE score IN (SELECT TOP 2 score FROM SC WHERE t1.CourseId= CourseId ORDER BY score DESC ) ORDER BY t1.CourseId; 统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列 1234select CourseId as 课程号,count(*) as 人数from sc group by CourseIdorder by count(*) desc,CourseId 检索至少选修两门课程的学生学号 1234select StudentId from sc group by StudentIdhaving count(*) &gt; = 2 查询全部学生都选修的课程的课程号和课程名 123select CourseId,Cname from Course where CourseId in (select CourseId from sc group by CourseId) 查询没学过“叶平”老师讲授的任一门课程的学生姓名 12345select Sname from Student where StudentId not in (select StudentId from Course,Teacher,SC where Course.TeacherId=Teacher.TeacherId and SC.CourseId=course.CourseId and Tname='叶平'); 查询两门以上不及格课程的同学的学号及其平均成绩 1234select StudentId,avg(isnull(score,0)) from SC where StudentId in (select StudentId from SC where score &lt;60 group by StudentId having count(*)&gt;2)group by StudentId; 检索“004”课程分数小于60，按分数降序排列的同学学号 1select StudentId from SC where CourseId='004'and score &lt;60 order by score desc; 删除“002”同学的“001”课程的成绩 1delete from Sc where StudentId='002'and CourseId='001'; 来源： http://blog.sina.com.cn/s/blog_95cfa64601016tui.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Linux——linux指令集合]]></title>
    <url>%2F2017%2F04%2F03%2F%E8%81%8A%E8%81%8ALinux%E2%80%94%E2%80%94linux%E6%8C%87%E4%BB%A4%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[本文整理了Linux大部分常用的命令，并加以分类。系统信息显示 系统信息显示 命令 说明 rch 显示机器的处理器架构(1) uname -m 显示机器的处理器架构(2) uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 ) 命令 说明 shutdown -h now 关闭系统(1) init 0 关闭系统(2) telinit 0 关闭系统(3) shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启(1) reboot 重启(2) logout 注销 防火墙1234service iptables stop 关闭防火墙service iptables status 验证防火墙 chkconfig iptables off 关闭防火墙的自动运行chkconfig --list | grep iptables 防火墙自动开启状态 文件和目录 命令 说明 cd /home 进入 ‘/ home’ 目录’ cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls [0-9] 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构(1) lstree 显示文件和目录由根目录开始的树形结构(2) mkdir dir1 创建一个叫做 ‘dir1’ 的目录’ mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 ‘file1’ 的文件’ rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/* . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) ###文件搜索 命令 说明 find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 ‘user1’ 的文件和目录 find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限 find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备 locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统 命令 说明 mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在 umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出 fuser -km /mnt/hda2 当设备繁忙时强制卸载 umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时 mount /dev/fd0 /mnt/floppy 挂载一个软盘 mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间12345678df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 'dir1' 已经使用的磁盘空间'du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a --qf '%10&#123;SIZE&#125;t%&#123;NAME&#125;n' | sort -k1,1n #以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f='$&#123;Installed-Size;10&#125;t$&#123;Package&#125;n' | sort -k1,1n #以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组 groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录) usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 passwd 修改口令 passwd user1 修改一个用户的口令 (只允许root执行) chage -E 2005-12-31 user1 设置用户口令的失效期限 pwck 检查 ‘/etc/passwd’ 文件格式和语法修正以及存在的用户 grpck 检查 ‘/etc/passwd’ 文件格式和语法修正以及存在的群组 newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消123456789101112131415ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消 命令 说明 chattr +a file1 只允许以追加方式读写文件 chattr +c file1 允许这个文件能被内核自动压缩/解压 chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lsattr 显示特殊的属性 打包和压缩文件 命令 说明 bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件 bzip2 file1 压缩一个叫做 ‘file1’ 的文件 gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件 gzip file1 压缩一个叫做 ‘file1’的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包 rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1 rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）1234567891011121314151617181920212223242526rpm -ivh package.rpm安装一个rpm包rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 "httpd" 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg "System Environment/Daemons" 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name --whatprovides 显示一个rpm包所占的体积rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name --changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm --checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统） 命令 说明 yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)12345678dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 "httpd" 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统) 命令 说明 apt-get install package_name 安装/更新一个 deb 包 apt-cdrom install package_name 从光盘安装/更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容 命令 说明 cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理12345678910111213141516171819202122232425262728293031cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUTcat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中grep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词"Aug"grep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以"Aug"开始的词汇grep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行grep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串"Aug"sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 "string1" 替换成 "string2"sed '/^$/d' example.txt 从example.txt文件中删除所有空白行sed '/ *#/d; /^$/d' example.txt 从example.txt文件中删除所有注释和空白行echo 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容sed -e '1d' result.txt 从文件example.txt 中排除第一行sed -n '/stringa1/p' 查看只包含词汇 "string1"的行sed -e 's/ *$//' example.txt 删除每一行最后的空白字符sed -e 's/stringa1//g' example.txt 从文档中只删除词汇 "string1" 并保留剩余全部sed -n '1,5p;5q' example.txt 查看从第一行到第5行内容sed -n '5p;5q' example.txt 查看第5行sed -e 's/00*/0/g' example.txt 用单个零替换多个零cat -n file1 标示文件的行数cat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行echo a b c | awk '&#123;print $1&#125;' 查看一行第一栏echo a b c | awk '&#123;print $1,$3&#125;' 查看一行的第一和第三栏paste file1 file2 合并两个文件或两栏的内容paste -d '+' file1 file2 合并两个文件或两栏的内容，中间用"+"区分sort file1 file2 排序两个文件的内容sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)sort file1 file2 | uniq -u 删除交集，留下其他的行sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换1234dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIXunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOSrecode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成htmlrecode -l | more 显示所有允许的转换格式 文件系统分析 命令 说明 badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整 fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统 命令 说明 mkfs /dev/hda1 在hda1分区创建一个文件系统 mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 fdformat -n /dev/fd0 格式化一个软盘 mkswap /dev/hda3 创建一个swap文件系统 SWAP文件系统 命令 说明 mkswap /dev/hda3 创建一个swap文件系统 swapon /dev/hda3 启用一个新的swap文件系统 swapon /dev/hda2 /dev/hdb3 启用两个swap分区 备份1234567891011121314151617dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份dump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份restore -if /tmp/home0.bak 还原一个交互式备份rsync -rogpav --delete /home /tmp 同步两边的目录rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsyncrsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz' 通过ssh在远程主机上执行一次备份本地磁盘的操作dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件tar -Puf backup.tar /home/user 执行一次对 '/home/user' 目录的交互式备份操作( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr 'cd /home/share/ &amp;&amp; tar x -p' 通过ssh在远程目录中复制一个目录内容( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home &amp;&amp; tar x -p' 通过ssh在远程目录中复制一个本地目录tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 '.txt' 结尾的文件到另一个目录find /var/log -name '*.log' | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 '.log' 结尾的文件并做成一个bzip包dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 光盘1234cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件mkisofs -J -allow-leading-dots -R -V "Label CD" -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso 网络 - （以太网和WIFI无线） 命令 说明 ifconfig eth0 显示一个以太网卡的配置 ifup eth0 启用一个 ‘eth0’ 网络设备 ifdown eth0 禁用一个 ‘eth0’ 网络设备 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing) dhclient eth0 以dhcp模式启用 ‘eth0’ route -n show routing table route add -net 0/0 gw IP_Gateway configura default gateway route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’ route del 0/0 gw IP_gateway remove static route echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing hostname show hostname of system host www.example.com lookup hostname to resolve name to ip address and viceversa(1) nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2) ip link show show link status of all interfaces mii-tool eth0 show link status of ‘eth0’ ethtool eth0 show statistics of network card ‘eth0’ netstat -tup show all active network connections and their PID netstat -tupl show all network services listening on the system and their PID tcpdump tcp port 80 s how all HTTP traffic iwlist scan show wireless networks iwconfig eth1 show configuration of a wireless network card hostname show hostname whois www.example.com lookup on Whois database]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——java面试（三）]]></title>
    <url>%2F2017%2F04%2F02%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94Java%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[中间件、设计模式、虚拟机面试题整理 中间件 REDIS和MEMORYCATCH区别数据类型redis数据类型丰富，支持set liset等类型memcache支持简单数据类型，需要客户端自己处理复杂对象持久性redis支持数据落地持久化存储memcache不支持数据持久存储分布式存储redis支持master-slave复制模式memcache可以使用一致性hash做分布式value大小不同memcache是一个内存缓存，key的长度小于250字符，单个item存储要小于1M，不适合虚拟机使用数据一致性不同redis使用的是单线程模型，保证了数据按顺序提交。memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作cpu利用redis单线程模型只能使用一个cpu，可以开启多个redis进程a、存储方式Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。b、数据支持类型Memcache对数据类型支持相对简单。Redis有复杂的数据类型。c、使用底层模型不同它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 分布式缓存和本地缓存的异同点，各自应用场景请举例 本地缓存:数据存储在应用代码所在内存空间.优点是可以提供快速的数据访问;缺点是数据无法分布式共享,无容错处理.典型的,如Cache4j; 分布式缓存系统:数据在固定数目的集群节点间分布存储.优点是缓存容量可扩展(静态扩展);缺点是扩展过程中需要大量配置,无容错机制 nginx怎么保证各各web容器之间不会串nginx上通过配置独立的虚拟主机来进行隔离 Maven的生命周期三套相互独立的生命周期Maven有三套相互独立的生命周期，分别是clean、default和site。每个生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。clean生命周期1、clean生命周期：清理项目，包含三个phase。1）pre-clean：执行清理前需要完成的工作2）clean：清理上一次构建生成的文件3）post-clean：执行清理后需要完成的工作 2、default生命周期：构建项目，重要的phase如下。 1）validate：验证工程是否正确，所有需要的资源是否可用。2）compile：编译项目的源代码。3）test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。4）Package：把已编译的代码打包成可发布的格式，比如jar。5）integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。6）verify：运行所有检查，验证包是否有效且达到质量标准。7）install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。8）Deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。 3、site生命周期：建立和发布项目站点，phase如下 1）pre-site：生成项目站点之前需要完成的工作2）site：生成项目站点文档3）post-site：生成项目站点之后需要完成的工作4）site-deploy：将项目站点发布到服务器三、命令行和生命周期各个生命周期相互独立，一个生命周期的阶段前后依赖。举例如下：1、mvn clean调用clean生命周期的clean阶段，实际执行pre-clean和clean阶段2、mvn test调用default生命周期的test阶段，实际执行test以及之前所有阶段3、mvn clean install调用clean生命周期的clean阶段和default的install阶段，实际执行pre-clean和clean，install以及之前所有阶段 5.redis的持久化第一种方法filesnapshotting：默认redis是会以快照的形式将数据持久化到磁盘的（一个二进制文件，dump.rdb，这个文件名字可以指定），在配置文件中的格式是：save N M表示在N秒之内，redis至少发生M次修改则redis抓快照到磁盘。当然我们也可以手动执行save或者bgsave（异步）做快照。工作原理简单介绍一下：当redis需要做持久化时，redis会fork一个子进程；子进程将数据写到磁盘上一个临时RDB文件中；当子进程完成写临时文件后，将原来的RDB替换掉，这样的好处就是可以copy-on-write还有一种持久化方法是Append-only：filesnapshotting方法在redis异常死掉时，最近的数据会丢失（丢失数据的多少视你save策略的配置），所以这是它最大的缺点，当业务量很大时，丢失的数据是很多的。Append-only方法可以做到全部数据不丢失，但redis的性能就要差些。AOF就可以做到全程持久化，只需要在配置文件中开启（默认是no），appendonly yes开启AOF之后，redis每执行一个修改数据的命令，都会把它添加到aof文件中，当redis重启时，将会读取AOF文件进行“重放”以恢复到redis关闭前的最后时刻。LOG Rewriting随着修改数据的执行AOF文件会越来越大，其中很多内容记录某一个key的变化情况。因此redis有了一种比较有意思的特性：在后台重建AOF文件，而不会影响client端操作。在任何时候执行BGREWRITEAOF命令，都会把当前内存中最短序列的命令写到磁盘，这些命令可以完全构建当前的数据情况，而不会存在多余的变化情况（比如状态变化，计数器变化等），缩小的AOF文件的大小。所以当使用AOF时，redis推荐同时使用BGREWRITEAOF。 6.分布式缓存概述1.1 分布式缓存的特性分布式缓存具有如下特性:1) 高性能:当传统数据库面临大规模数据访问时,磁盘I/O 往往成为性能瓶颈,从而导致过高的响应延迟.分布式缓存将高速内存作为数据对象的存储介质,数据以key/value 形式存储,理想情况下可以获得DRAM 级的读写性能;2) 动态扩展性:支持弹性扩展,通过动态增加或减少节点应对变化的数据访问负载,提供可预测的性能与扩展性;同时,最大限度地提高资源利用率;3) 高可用性:可用性包含数据可用性与服务可用性两方面.基于冗余机制实现高可用性,无单点失效(single point of failure),支持故障的自动发现,透明地实施故障切换,不会因服务器故障而导致缓存服务中断或数据丢失.动态扩展时自动均衡数据分区,同时保障缓存服务持续可用;4) 易用性:提供单一的数据与管理视图;API 接口简单,且与拓扑结构无关;动态扩展或失效恢复时无需人工配置;自动选取备份节点;多数缓存系统提供了图形化的管理控制台,便于统一维护;5) 分布式代码执行(distributed code execution):将任务代码转移到各数据节点并行执行,客户端聚合返回结果,从而有效避免了缓存数据的移动与传输.最新的Java 数据网格规范JSR-347中加入了分布式代码执行与Map/reduce 的API 支持,各主流分布式缓存产品,如IBM WebSphere eXtreme Scale,VMware GemFire,GigaSpaces XAP 和Red Hat Infinispan 等也都支持这一新的编程模型.1.2 典型应用场景分布式缓存的典型应用场景可分为以下几类:1) 页面缓存.用来缓存Web 页面的内容片段,包括HTML、CSS 和图片等,多应用于社交网站等;2) 应用对象缓存.缓存系统作为ORM 框架的二级缓存对外提供服务,目的是减轻数据库的负载压力,加速应用访问;3) 状态缓存.缓存包括Session 会话状态及应用横向扩展时的状态数据等,这类数据一般是难以恢复的,对可用性要求较高,多应用于高可用集群;4) 并行处理.通常涉及大量中间计算结果需要共享;5) 事件处理.分布式缓存提供了针对事件流的连续查询(continuous query)处理技术,满足实时性需求;6) 极限事务处理.分布式缓存为事务型应用提供高吞吐率、低延时的解决方案,支持高并发事务请求处理,多应用于铁路、金融服务和电信等领域.1.3 分布式缓存的发展分布式缓存经历了多个发展阶段,由最初的本地缓存到弹性缓存平台直至弹性应用平台,目标是朝着构建更好的分布式系统方向发展(如下图所示).1) 本地缓存:数据存储在应用代码所在内存空间.优点是可以提供快速的数据访问;缺点是数据无法分布式共享,无容错处理.典型的,如Cache4j;2) 分布式缓存系统:数据在固定数目的集群节点间分布存储.优点是缓存容量可扩展(静态扩展);缺点是扩展过程中需要大量配置,无容错机制 ActiveMQ优势1.与OpenJMS、JbossMQ等开源jms provider相比，ActiveMQ有Apache的支持，持续发展的优势明显。2.速度很快，JBossMQ的十倍(没有测试)3.提高系统资源的利用率，主要是任务的派发不是24小时平均的，而是高峰时期任务量很多，比如1秒1000多个，有的时候很低，比如十几秒钟才来一个。 redis 五种数据类型String，Hash，List，Set，Sort Set Maven有哪些优点和缺点优点如下：简化了项目依赖管理：易于上手，对于新手可能一个”mvn clean package”命令就可能满足他的工作便于与持续集成工具（jenkins）整合便于项目升级，无论是项目本身升级还是项目使用的依赖升级。有助于多模块项目的开发，一个模块开发好后，发布到仓库，依赖该模块时可以直接从仓库更新，而不用自己去编译。maven有很多插件，便于功能扩展，比如生产站点，自动发布版本等缺点如下：maven是一个庞大的构建系统，学习难度大maven采用约定优于配置的策略（convention over configuration），虽然上手容易，但是一旦出了问题，难于调试。当依赖很多时，m2eclipse 老是搞得Eclipse很卡。中国的网络环境差，很多repository无法访问，比如google code， jboss 仓库无法访问等。 我们经常使用“Mvn Clean Package”命令进行项目打包，请问该命令执行了哪些动作来完成该任务？在这个命令中我们调用了maven的clean周期的clean阶段绑定的插件任务，以及default周期的package阶段绑定的插件任务默认执行的任务有（maven的术语叫goal, 也有人翻译成目标，我这里用任务啦）： maven-clean-plugin:clean-&gt; maven-resources-plugin:resources-&gt; maven-compile-plugin:compile-&gt; mavne-resources-plugin:testResources-&gt; maven-compile-plugin:testCompile-&gt; maven-jar-plugin:jar Maven依赖的解析机制解析发布版本：如果本地有，直接使用本地的，没有就向远程仓库请求。解析快照版本：合并本地和远程仓库的元数据文件-groupId/artifactId/version/maven-metadata.xml，这个文件存的版本都是带时间戳的，将最新的一个改名为不带时间戳的格式供本次编译使用。解析版本为LATEST,RELEASE，过于复杂，且解析的结果不稳定， 不推荐在项目中使用，感兴趣的同学自己去研究，简而言之就是合并groupId/artifactId/maven-metadata.xml找到对应的最新版本和包含快照的最新版本。 sonarqube(唢呐曲贝)代码质量管理平台 JMS介绍简介：应用于系统之间信息异步传递解耦的分布式且实现生产者消费者模式的中间件软件基本概念：消息：生产者与消费者中间约定的消息对象队列：实现线程安全／消息有序存放的地方通道：队列管理器信息传递信息的管道发送方：生产者接受方：消费者通讯模式：点对点发布／订阅多点广播群集消息模型：消息头（header）：JMS消息头包含了许多字段，它们是消息发送后由JMS提供者或消息发送者产生，用来表示消息、设置优先权和失效时间等等，并且为消息确定路由。属性（property）：由消息发送者产生，用来添加删除消息头以外的附加信息。消息体（body）：由消息发送者产生，JMS中定义了5种消息体：ByteMessage、MapMessage、ObjectMessage、StreamMessage和TextMessage。 设计模式 写一个Singleton出来。 12345678910111213141516171819202122232425//第一种：饱汉模式 public classSingleTon &#123; private SingleTon()&#123; &#125; //实例化放在静态代码块里可提高程序的执行效率，但也可能更占用空间 private final static SingleTon instance =new SingleTon(); public static SingleTon getInstance()&#123; return instance; &#125; &#125; //第二种：饥汉模式 public classSingleTon &#123; private SingleTon()&#123; &#125; private static instance = null;//newSingleTon(); public static synchronized SingleTongetInstance()&#123; if(instance == null) instance = new SingleTon(); return instance; &#125; &#125;&#125; ​ 单例的优缺点主要优点：1、提供了对唯一实例的受控访问。2、由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。3、允许可变数目的实例。主要缺点：1、由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。2、单例类的职责过重，在一定程度上违背了“单一职责原则”。3、滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。不易扩展，不调用易被回收，指责过重 3.设计模式的原则 1、开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 4.设计模式分类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 工厂模式PK简单工厂模式：1、工厂模式的优点：工厂模式是简单工厂模式的进一步抽象和推广。它遵循了“开放—封闭”原则。2、简单工厂模式的优点：简单工厂模式最大的优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。3、工厂模式的缺点：工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来执行；每增加一产品就要增加一个产品工厂的类，增加了额外的开发量。4、简单工厂的缺点：是没有遵守开放—封闭原则。所谓的“开放-封闭”原则就是开放接口，封闭修改。如果将来需要添加一个开方的算法，那么，在简单工厂模式中，就必须在简单工厂类中添加相应的判断语句！另外，在简单工厂类中利用了Switch语句，这对程序的扩展本身就不不利。 抽象工厂的优缺点:优点：1、抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建。2、当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。3、增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。缺点：增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。 标准的JDK库中使用的一些设计模式Decorator设计模式常被用于各种Java IO类中Singleton模式常被用在运行环节中，Calendar以及各种其他类Factory（工厂）模式常被用于各种不可变类，比如Boolean。Boolean.valueOfObserver模式常被用于Swing和许多事件监听器框架中。 使用Factory模式主要优势是什么？你会在哪种情况下使用？Factory模式最主要的优势在于当创建对象时可提高封装水平。如果你使用Factory模式来创建对象，你可以在后期重置最初产品的装置或者无须任何客户层就可实现更先进更高性能的类。可以查看我曾发表过的有关Factory模式的更多细节及优点。 虚拟机 描述一下JVM加载class文件的原理机制?JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。1.创建JVM装载环境和配置2.装载JVM.dll3.初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例4.调用JNIEnv实例装载并处理class类–&gt;加载－验证－准备－解析－初始化 heap和stack有什么区别。java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。 GC是什么?为什么要有GC?GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 垃圾回收的优点和原理 引用计数（Reference Counting）比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。 标记-清除（Mark-Sweep）此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。 复制（Copying）此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不过出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。 标记-整理（Mark-Compact）此算法结合了 “标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象 “压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。 增量收集（Incremental Collecting）实施垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。 分代（Generational Collecting） Java内存模型简要说明程序计数器Java虚拟机栈本地方法栈Java堆方法区（也称为永久代／永久区，存放常量，类信息，静态变量等）直接内存 垃圾回收机制 标记－清除收集器 标记－压缩收集器 复制收集器 增量收集器 堆的划分堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。新生代：程序新创建的对象都是从新生代分配内存，划分：Eden space, From space, To Space老年代：用于存放经过多次新生代GC任然存活的对 JVM内存参数设置及调优 JVM的内存管理机制java的内存管理就是对象的分配和释放问题。（两部分）分配 ：内存的分配是由程序完成的，程序员需要通过关键字new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。释放(垃圾回收) ：对象的释放是由垃圾回收机制决定和执行的，这样做确实简化了程序员的工作。但同时，它也加重了JVM的工作。因为，GC为了能够正确释放对象，GC必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC都需要进行监控。 什么时候发生栈溢出和内存溢出如果线程请求的栈深度大于虚拟机所允许的最大深达，则stackOverFlowError如果虚拟机在扩展栈／堆时无法申请到足够的内存空间，则OutOfMemoryError JVM工具jsp/jhat/jmap/jstack/jinfo/jconsole ClassLoader类加载过程加载核心类-》加载扩展类-》加载自定义类-》判断内存是否存在该内存-》调用父类加载器加载此类-》寻找class文件-》将class文件加载内存（加载－验证－准备－解析－初始化）-》装载完成 什么情况下触发full gc、频繁的full gc可能的原因 调用System.gc 老年代空间不足 永久代空间不足 gc担保失败 Cocurrent mode failure 14.内存溢出如何定位Java虚拟机在栈中定义了两种异常，StrackOverFlowError和OutOfMemeryError。当请求栈的深度大于java虚拟机所允许的最大深度则抛出StrackOverFlowError；如果Java虚拟机在栈扩展时，没有申请到足够的空间时，则抛出OutOfMemeryError。堆内存的溢出比较复杂，需要调节GC等多种参数3、JVM垃圾收集相关]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Linux——Zookeeper安装]]></title>
    <url>%2F2017%2F04%2F02%2F%E8%81%8A%E8%81%8ALinux%E2%80%94%E2%80%94Zookeeper%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本文介绍Linux安装Zookeeper步骤。 注册中心服务器（ 192.168.1.215）配置， 安装 Zookeeper: 1、 修改操作系统的/etc/hosts 文件中添加： 12# zookeeper servers192.168.1.215 hadoop-215 2、 到 http://apache.fayea.com/zookeeper/下载 zookeeper-3.4.6： 1$ wget http://apache.fayea.com/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz 3、 解压 zookeeper 安装包： 1$ tar -zxvf zookeeper-3.4.6.tar.gz 4、 在/home/hadoop/zookeeper-3.4.6 目录下创建以下目录： 123$ cd /home/hadoop/zookeeper-3.4.6$ mkdir data$ mkdir logs 5、 将 zookeeper-3.4.6/conf 目录下的 zoo_sample.cfg 文件拷贝一份，命名为为zoo.cfg 1$ cp zoo_sample.cfg zoo.cfg 6、 修改 zoo.cfg 配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940$ vi zoo.cfg# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/home/hadoop/zookeeper-3.4.6/datadataLogDir=/home/hadoop/zookeeper-3.4.6/logs# the port at which the clients will connectclientPort=2181#2888,3888 are election portserver.1=edu-provider-01:2888:3888其中，2888 端口号是 zookeeper 服务之间通信的端口。3888 是 zookeeper 与其他应用程序通信的端口。edu-provider-01 是在 hosts 中已映射了 IP 的主机名。initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是5*2000=10 秒。syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4秒。server.A=B:C:D：其中 A 是一个数字，表示这个是第几号服务器； B 是这个服务器的 IP 地址或/etc/hosts 文件中映射了 IP 的主机名； C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口； D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号 7、 在 dataDir=/home/hadoop/zookeeper-3.4.6/data 下创建 myid 文件编辑 myid 文件，并在对应的 IP 的机器上输入对应的编号。如在 zookeeper 上， myid文件内容就是 1。 如果只在单点上进行安装配置， 那么只有一个 server.1。 12$ vi myid1 8、 hadoop用户下修改 vi /home/hadoop/.bash_profile， 增加 zookeeper 配置： 123456#zookeeper envexport ZOOKEEPER_HOME=/home/hadoop/zookeeper-3.4.6export PATH=ZOOKEEPER_HOME/bin:PATH#使配置文件生效$ source /home/hadoop/.bash_profile 9、 在防火墙中打开要用到的端口 2181、 2888、 3888切换到 root 用户权限，执行以下命令: 123456789101112chkconfig iptables onservice iptables start#编辑/etc/sysconfig/iptablesvi /etc/sysconfig/iptables#增加以下 3 行：-A INPUT -m state --state NEW -m tcp -p tcp --dport 2181 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 2888 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 3888 -j ACCEPT#重启防火墙：service iptables restart#查看防火墙端口状态：service iptables statu 10、 启动并测试 zookeeper（ 要用 hadoop 用户启动，不要用 root） : 123456789101112(1) 使用 hadoop 用户到/home/hadoop/zookeeper-3.4.6/bin 目录中执行：$ zkServer.sh start(2) 输入 jps 命令查看进程： $ jps1456 QuorumPeerMain1475 Jps其中， QuorumPeerMain 是 zookeeper 进程，启动正常(3) 查看状态： $ zkServer.sh status(4) 查看 zookeeper 服务输出信息：由于服务信息输出文件在/home/hadoop/zookeeper-3.4.6/bin/zookeeper.out$ tail -500f zookeeper.out 11、 停止 zookeeper 进程： 1$ zkServer.sh stop 12、 配置 zookeeper 开机使用 hadoop 用户启动：编辑/etc/rc.local 文件，加入： 1su - hadoop -c '/home/hadoop/zookeeper-3.4.6/bin/zkServer.sh start']]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——java面试（二）]]></title>
    <url>%2F2017%2F04%2F02%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94Java%E9%9D%A2%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Web相关、架构知识面试题整理 Web相关 Tomcat的优化经验+线程优化： 1234maxThreads=&quot;600&quot; //最大线程数minSpareThreads=&quot;100&quot; //初始化时创建的线程数maxSpareThreads=&quot;500&quot; //一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。acceptCount=&quot;700&quot; //指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理 Apr插件提高Tomcat性能:使用APR来提供超强的可伸缩性和性能，更好地集成本地服务器技术 设置session过期时间： 禁用DNS查询 内存优化： 1JAVA_OPTS=&quot;-XX:PermSize=64M -XX:MaxPermSize=128m -Xms512m -Xmx1024m -Duser.timezone=Asia/Shanghai&quot; 解释一下什么是servlet;基于Java编程语言的WEB服务器端编程技术 SERVLET API中forward()与redirect()的区别？一次转发，一次请求，两次请求，两次转发，资源消耗 jsp有哪些内置对象?作用分别是什么?分别有什么方法？ request 用户端请求，此请求会包含来自GET/POST请求的参数 response 网页传回用户端的回应 pageContext 网页的属性是在这里管理 session 与请求有关的会话期 application servlet 正在执行的内容 out 用来传送回应的输出 config servlet的构架部件 page JSP网页本身 exception 针对错误网页，未捕捉的例外 tomcat服务器的配置文件， bin conf logs webapps common 怎么优化长SQL a)explain Sql，解释执行分析执行效率，主要是查询是否用到索引，索引是SQL优化的重点 b)exist 代替 in c)join 代替 子查询 d)存储过程 e) 分库分表 f) 读写分离 g)索引使用的问题 ​ 数据库 数据库死锁处理方法： 根据2中提供的sql，查看那个spid处于wait状态，然后用kill spid来干掉(即破坏死锁的第四个必要条件:循环等待)；当然这只是一种临时解决方案，我们总不能在遇到死锁就在用户的生产环境上排查死锁、Kill sp，我们应该考虑如何去避免死锁。 使用SET LOCK_TIMEOUT timeout_period(单位为毫秒)来设定锁请求超时。默认情况下，数据库没有超时期限(timeout_period值为-1，可以用SELECT @@LOCK_TIMEOUT来查看该值，即无限期等待)。当请求锁超过timeout_period时，将返回错误。timeout_period值为0时表示根本不等待，一遇到锁就返回消息。设置锁请求超时，破环了死锁的第二个必要条件(请求与保持条件)。 服务器: 消息 1222，级别 16，状态 50，行 1 已超过了锁请求超时时段。 SQL Server内部有一个锁监视器线程执行死锁检查，锁监视器对特定线程启动死锁搜索时，会标识线程正在等待的资源；然后查找特定资源的所有者，并递归地继续执行对那些线程的死锁搜索，直到找到一个构成死锁条件的循环。检测到死锁后，数据库引擎 选择运行回滚开销最小的事务的会话作为死锁牺牲品，返回1205 错误，回滚死锁牺牲品的事务并释放该事务持有的所有锁，使其他线程的事务可以请求资源并继续运行。 mysql索引的数据结构，加索引的原则where后的条件，order by ,group by 等这样过滤时，后面的字段最好加上索引，联合查询，子查询等多表操作时关连字段要加索引 innodb和myisam的区别innodb:保存表空间数据文件和日志文件。支持事物，适合大量增删改，查询比myisam慢。支持行锁表。myisam：保存时保存3个文件，不支持事物，适合执行大量查询，不支持行锁表 以及常见的mysql优化方案，1、选取最适用的字段属性2、使用连接（JOIN）来代替子查询（Sub-Queries）3、使用联合（UNION）来代替手动创建的临时表使用索引优化的查询语句 a: 表的设计合理化(符合3NF) b: 添加适当索引(index) [四种: 普通索引、主键索引、唯一索引unique、全文索引] c: 分表技术(水平分割、垂直分割) d: 读写[写: update/delete/add]分离 e: 存储过程 [模块化编程，可以提高速度] f: 对mysql配置优化 [配置最大并发数my.ini, 调整缓存大小 ] g: mysql服务器硬件升级 h: 定时的去清除不需要的数据,定时进行碎片整理(MyISAM) oracle索引种类 单列索引与复合索引 一个索引可以由一个或多个列组成，用来创建索引的列被称为“索引列”。 单列索引是基于单列所创建的索引，复合索引是基于两列或者多列所创建的索引。 唯一索引与非唯一索引 唯一索引是索引列值不能重复的索引，非唯一索引是索引列可以重复的索引。 无论是唯一索引还是非唯一索引，索引列都允许取NULL值。默认情况下，Oracle创建的索引是不唯一索引。 B树索引 B树索引是按B树算法组织并存放索引数据的，所以B树索引主要依赖其组织并存放索引数据的算法来实现快速检索功能。 位图索引 位图索引在多列查询时，可以对两个列上的位图进行AND和OR操作，达到更好的查询效果。 函数索引 Oracle中不仅能够直接对表中的列创建索引，还可以对包含列的函数或表达式创建索引，这种索引称为“位图索引” Oracle和mysql中对分页的sql处理区别，可任选一种写出例子 123456789select * from a limit 0, 10;------------------------------------------------SELECT * FROM (SELECT A.*, ROWNUM RN FROM A) WHERE RN BETWEEN 21 AND 40 ;-------------------------------------------------SELECT * FROM (SELECT A.*, ROWNUM RN FROM (SELECT * FROM TABLE_NAME) A WHERE ROWNUM &lt;= 40) WHERE RN &gt;= 21; 数据库三范式是什么第一范式：每一列都是不可分割第二范式：属性完全依赖于主键，满足第一范式第三范式：非主关键字信息仅存一表，满足第二范式 union和union all有什么不同? Union，对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；Union All，对两个结果集进行并集操作，包括重复行，不进行排序； SQL分哪几类？ DDL，DML，DCL 数据库事务原子性。即不可分割性，事务要么全部被执行，要么就全部不被执行。一致性。事务的执行使得数据库从一种正确状态转换成另一种正确状态隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。 死锁及处理：事务循环等待数据锁，则会死锁。死锁处理：预防死锁协议，死锁恢复机制 数据库SQL练习查看笔记SQL练习 Mysql索引的分类普通索引唯一索引主键（特殊的唯一索引）复合索引 索引添加规则索引查询是数据库中重要的记录查询方法，要不要进入索引以及在那些字段上建立索引都要和实际数据库系统的查询要求结合来考虑，下面给出实际中的一些通用的原则： 在经常用作过滤器的字段上建立索引； 在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引； 在不同值较少的字段上不必要建立索引，如性别字段； 对于经常存取的列避免建立索引； 用于联接的列（主健/外健）上建立索引； 在经常存取的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频度来确定； 缺省情况下建立的是非簇集索引，但在以下情况下最好考虑簇集索引，如：含有有限数目（不是很少）唯一的列；进行大范围的查询；充分的利用索引可以减少表扫描I/0的次数，有效的避免对整表的搜索。当然合理的索引要建立在对各种查询的分析和预测中，也取决于DBA的所设计的数据库结构。 悲观锁，乐观锁（可查数据库笔记）悲观锁：自己拿着锁，别人不能动 悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人也会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁： 乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。 数据库中的事务是什么?事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。 优化MYSQL数据库的方法。1、选择合适的字段的数据类型 1)能用数字不用字符串 2)char、varchar、text 能用varchar不用char 3）给字段加not null 避免在表中出现NULL关键字(default值) 2、选择合适的字段充当主键 1)建议每张表必须有主键 2)用数字类型的字段充当主键 3、拆分表 1）拆分字段，将文章的标题与内容分开 2）拆分记录，将今年的记录与往年的记录分开 4、给字段合理添加索引 a.格式: 普通索引)-&gt; 创建:CREATE INDEX &lt;索引名&gt; ON tablename (索引字段) 修改:ALTER TABLE tablename ADD INDEX [索引名] (索引字段) 创表指定索引:CREATE TABLE tablename([...],INDEX[索引名](索引字段) (唯一索引)-&gt; 创建:CREATE UNIQUE &lt;索引名&gt; ON tablename (索引字段) 修改:ALTER TABLE tablename ADD UNIQUE [索引名] (索引字段) 创表指定索引:CREATE TABLE tablename([...],UNIQUE[索引名](索引字段) (主键)-&gt; 它是唯一索引,一般在创建表是建立,格式为: CREATA TABLE tablename ([...],PRIMARY KEY[索引字段]) 5、事务处理: a.保证数据完整性,例如添加和修改同时,两者成立则都执行,一者失败都失败 mysql_query(&quot;BEGIN&quot;); mysql_query(&quot;INSERT INTO customerinfo (name) VALUES (&apos;$name1&apos;)&quot;; mysql_query(&quot;SELECT * FROM `orderinfo` where customerid=&quot;.$id&quot;); mysql_query(&quot;COMMIT&quot;); 6、锁定表,优化事务处理: a.我们用一个 SELECT 语句取出初始数据，通过一些计算，用 UPDATE 语句将新值更新到表中。 包含有 WRITE 关键字的 LOCK TABLE 语句可以保证在UNLOCK TABLES 命令被执行之前， 不会有其它的访问来对 inventory 进行插入、更新或者删除的操作 mysql_query(&quot;LOCK TABLE customerinfo READ, orderinfo WRITE&quot;); mysql_query(&quot;SELECT customerid FROM `customerinfo` where id=&quot;.$id); mysql_query(&quot;UPDATE `orderinfo` SET ordertitle=&apos;$title&apos; where customerid=&quot;.$id); mysql_query(&quot;UNLOCK TABLES&quot;); 7、使用外键,优化锁定表 12345678910111213141516a.把customerinfo里的customerid映射到orderinfo里的customerid,任何一条没有合法的customerid的记录不会写到orderinfo里CREATE TABLE customerinfo( customerid INT NOT NULL, PRIMARY KEY(customerid) )TYPE = INNODB; CREATE TABLE orderinfo( orderid INT NOT NULL, customerid INT NOT NULL, PRIMARY KEY(customerid,orderid), FOREIGN KEY (customerid) REFERENCES customerinfo(customerid) ON DELETE CASCADE )TYPE = INNODB;注意:'ON DELETE CASCADE',该参数保证当customerinfo表中的一条记录删除的话同时也会删除order表中的该用户的所有记录,注意使用外键要定义事务安全类型为INNODB; 优化查询语句 123456789101112131415161718用内连接代替子查询代替子查询，用sphinx代替like模糊查询最好在相同字段进行比较操作,在建立好的索引字段上尽量减少函数操作 例子1: SELECT * FROM order WHERE YEAR(orderDate)&lt;2008;(慢) SELECT * FROM order WHERE orderDate&lt;"2008-01-01";(快) 例子2: SELECT * FROM order WHERE addtime/7&lt;24;(慢) SELECT * FROM order WHERE addtime&lt;24*7;(快) 例子3: SELECT * FROM order WHERE title like "%good%"; SELECT * FROM order WHERE title&gt;="good" and name&lt;"good";9、缓存，静态化10、选择合适存储引擎用Innodb增删改，用myisam查询11、主从数据库12、负载均衡13、最好拿数字类型的字段充当where条件14、最好拿相同类型的字段进行比对(避免发生数据类型的转换)15、不要在具有索引的字段上添加数据库函数(索引失效) 请简述项目中优化sql语句执行效率的方法,从哪些方面,sql语句性能如何分析?（1）选择最有效率的表名顺序（2）WHERE子句中的连接顺序（3）SELECT子句中避免使用‘*’（4）用Where子句替换HAVING子句（5）通过内部函数提高SQL效率（6）避免在索引列上使用计算。（7）提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉。 架构知识 spring的事务原理Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。分为: 声明式跟编程式。声明式就是在Spring的配置文件中进行相关配置； 编程式就是用注解的方式写到代码里。下面先说声明式 Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。 DataSource、 TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用Hibernate进行数据访问时，DataSource实际为 SessionFactory，TransactionManager的实现为HibernateTransactionManager。 ​ 介绍一下springSpring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。 ​ springMVC的原理 spring的优缺点优点轻量：Spring 是轻量的，基本的版本大约2MB。控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。容器：Spring 包含并管理应用中对象的生命周期和配置。MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。缺点：1、配置文件太多，2、后期的bug对应阶段，不容易判断问题所在。3.挺臃肿的 ibatis与Mybatis区别，Mybatis与Herbernate区别ibatis与Mybatis没区别，ORM与半ORM 什么是ORM对象关系映射，数据库字段与类的属性形成映射关系 spring运行的原理 IoC：概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系 核心：bean工厂；在Spring中，bean工厂创建的各个实例称作bean AOP(Aspect-Oriented Programming): 面向方面编程代理的两种方式： 静态代理： 针对每个具体类分别编写代理类； 针对一个接口编写一个代理类； 动态代理： 针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类 现在为什么很多开发者选择SpringMVC？SpringMVC比Struts 2好吗？1.机制：spring mvc的入口是servlet，而struts2是filter（这里要指出，filter和servlet是不同的。 2.性能：spring会稍微比struts快。spring mvc是基于方法的设计，而sturts是基于类。 3.参数传递：struts是在接受参数的时候，可以用属性来接受参数，这就说明参数是让多个方法共享的。 4.设计思想上：struts更加符合oop的编程思想， spring就比较谨慎，在servlet上扩展。 5.intercepter的实现机制：struts有以自己的interceptor机制，spring mvc用的是独立的AOP方式。 6.另外，spring mvc的验证也是一个亮点，支持JSR303，处理ajax的请求更是方便，只需一个注解@ResponseBody ，然后直接返回响应文本即可。 7.struts2采用的传统的配置文件的方式，并没有使用传说中的0配置；spring mvc可以认为已经 有哪些不同类型的IOC（依赖注入）方式？构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。10.什么是Spring beans?Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建 解释Spring支持的几种bean的作用域。Spring框架支持以下五种bean的作用域：singleton : bean在每个Spring ioc 容器中只有一个实例。prototype：一个bean的定义可以有多个实例。request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 Spring框架中的单例bean是线程安全的吗?不安全，Spring框架中的单例bean不是线程安全的。 什么是bean装配?装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。 解释不同方式的自动装配 。有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。byType:：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。 解释AOP面向切面的编程，或AOP， 是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。运行时，动态的添加功能。 什么是Spring MVC框架的控制器？控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。 请解释Spring Bean的生命周期初始化之后调用的回调方法。销毁之前调用的回调方法。Spring框架提供了以下四种方式来管理bean的生命周期事件：InitializingBean和DisposableBean回调接口针对特殊行为的其他Aware接口Bean配置文件中的Custom init()方法和destroy()方法@PostConstruct和@PreDestroy注解方式 Spring 框架中都用到了哪些设计模式？ 代理模式—在AOP和remoting中被用的比较多。 单例模式—在spring配置文件中定义的bean默认为单例模式。 模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 前端控制器—Srping提供了DispatcherServlet来对请求进行分发。 视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。 依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。 工厂模式—BeanFactory用来创建对象的实例。 FileSystemResource和ClassPathResource有何区别？在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。 为什么喜欢使用spring喜欢1.轻量级2.易扩展兼容3.控制反转，AOP，事务的控制，不喜欢： zookeeper在Dubbo中扮演了一个什么角色，起到了什么作用Zookeeper一个分布式的服务框架，生产者发布注册提供自身信息，消费者订阅注册获取信息。是树型的目录服务的数据存储，能做到集群管理数据 ，这里能很好的作为Dubbo服务的注册中心，Dubbo能与Zookeeper做到集群部署，当提供者出现断电等异常停机时，Zookeeper注册中心能自动删除提供者信息，当提供者重启时，能自动恢复注册数据，以及订阅请求。 架构描述Dubbo：透明化远程调用可实现负载均衡容错机制的开发架构实现：集群容错/负载均衡/多协议/异步调用/参数调用等等功能Zookeeper:分布式的，开放源码的分布式应用程序协调服务]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Linux——JDK及MYSQL安装]]></title>
    <url>%2F2017%2F04%2F01%2F%E8%81%8A%E8%81%8ALinux%E2%80%94%E2%80%94JDK%E5%8F%8AMYSQL%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本文介绍Linux安装JDK及MySql5.6的步骤。 JDK安装1234567vi /etc/profile#jdkexport JAVA_HOME=/usr/local/jdkexport PATH=JAVA_HOME/bin:PATHexport CLASSPATH=:JAVA_HOME/lib/dt.jar:JAVA_HOME/lib/tools.jarsource /etc/profile Mysql安装1.新开的云服务器，需要检测系统是否自带安装mysql 1# yum list installed | grep mysql 2.如果发现有系统自带mysql，果断这么干 1# yum -y remove mysql-libs.x86_64 3.随便在你存放文件的目录下执行，这里解释一下，由于这个mysql的yum源服务器在国外，所以下载速度会比较慢，还好mysql5.6只有79M大，而mysql5.7就有182M了，所以这是我不想安装mysql5.7的原因 1# wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpm 4.接着执行这句,解释一下，这个rpm还不是mysql的安装文件，只是两个yum源文件，执行后，在/etc/yum.repos.d/ 这个目录下多出mysql-community-source.repo和mysql-community.repo 1# rpm -ivh mysql-community-release-el6-5.noarch.rpm 5.这个时候，可以用yum repolist mysql这个命令查看一下是否已经有mysql可安装文件 1#yum repolist all | grep mysql 6.安装mysql 服务器命令（一路yes）： 1# yum install mysql-community-server 7.安装成功后 1# service mysqld start 8.由于mysql刚刚安装完的时候，mysql的root用户的密码默认是空的，所以我们需要及时用mysql的root用户登录（第一次回车键，不用输入密码），并修改密码 123# mysql -u root# use mysql;# update user set password=PASSWORD("314159") where User='root'; 9.授权（自动创建）一个mysql的非root的aaa用户，能访问localhost上的testdb数据库，密码是xxxx，最后刷新权限 12# grant all privileges on testdb.* to aaa@localhost identified by 'xxxx';# flush privileges; 10.创建一个utf8的表(如果你有需要的话)之后退出 12# CREATE DATABASE `database` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; # exit; 11.查看mysql是否自启动,并且设置开启自启动命令 12# chkconfig --list | grep mysqld# chkconfig mysqld on 12.mysql安全设置(系统会一路问你几个问题，看不懂复制之后翻译，基本上一路yes)： 1# mysql_secure_installation 13.开远程 授权法 1234567891、新建用户远程连接mysql数据库grant all on *.* to admin@'%' identified by '314159' with grant option; flush privileges;允许任何ip地址(%表示允许任何ip地址)的电脑用admin帐户和密码(123456)来访问这个mysql server。注意admin账户不一定要存在。2、支持root用户允许远程连接mysql数据库grant all privileges on *.* to 'root'@'%' identified by '314159' with grant option;flush privileges; 改表法 12update user set host = '%' where user = 'root';flush privileges; 14.bye 1# exit]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——java面试（一）]]></title>
    <url>%2F2017%2F04%2F01%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94Java%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java基础、多线程面试题整理 Java基础 “==”和equals方法究竟有什么区别？ ==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同 equals方法是用于比较两个独立对象的内容是否相同 ​ ==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。a = “12”; b = “12”;a == b——》true equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。 ​ == 比较是否同一个引用 equal两个对象内容是否相同 阅读以下源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Objectpublic boolean equals(Object obj) &#123; return (this == obj);&#125;//Stringpublic boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125;//AbstractListpublic boolean equals(Object obj) &#123; if (obj == this) &#123; return true; &#125; if (obj instanceof List == false) &#123; return false; &#125; List other = (List) obj; if (other.size() != size()) &#123; return false; &#125; ListIterator it1 = listIterator(); ListIterator it2 = other.listIterator(); while (it1.hasNext() &amp;&amp; it2.hasNext()) &#123; Object o1 = it1.next(); Object o2 = it2.next(); if (!(o1 == null ? o2 == null : o1.equals(o2))) return false; &#125; return !(it1.hasNext() || it2.hasNext());&#125; ​ ​ 静态变量和实例变量的区别？ 在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。 在程序运行时的区别： ​ 实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。 ​ 静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了 Integer与int的区别？ int是java提供的8种原始数据类型之一。 Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。 int的默认值为0，而Integer的默认值为null 请说出作用域public，private，protected，以及不写时的区别 | 作用域 | 当前类 | 同包 | 子类 | 不同包 || ——— | —- | —- | —- | —- || public | 1 | 1 | 1 | 1 || protected | 1 | 1 | 1 | || friendly | 1 | 1 | | || private | 1 | | | | Overload和Override的区别 Override是重写：方法名称、参数个数，类型，顺序，返回值类型都是必须和父类方法一致的。它的关系是父子关系 Overload是重载:方法名称不变，其余的都是可以变更的。它的关系是同一个类，同一个方法名，不同的方法参数或返回值。 什么是面向对象的三大特性，继承的优缺点 封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。 继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。 ​ 优点： ​ 1.可以使用父类的所有非私有方法；而且单继承可由接口来弥补。 ​ 2.可以继承父类中定义的成员方法以及成员变量，使得子类可以减少代码的书写。还可以重写父类的方法以增加子类的功能。 ​ 缺点： ​ 1.耦合性太大 ​ 2.就是破坏了类的封装性，其实继承一般多用于抽象方法的继承和接口的实现 abstract class和interface有什么区别? 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 抽象类中可以包含静态方法，接口中不能包含静态方法 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类 型，并且默认即为public static final类型。 一个类可以实现多个接口，但只能继承一个抽象类。 内部类可以引用它的包含类的成员吗？有没有什么限制？ 完全可以。如果不是静态内部类，那没有什么限制！如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员 Anonymous Inner Class (匿名内部类)是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)? 可以继承其他类或实现其他接口。不仅是可以，而是必须! String和StringBuffer的区别,StringBuilder String属于immutable类，一旦发生改变只会新建对象，线程安全 StringBuffer类提供的字符串进行修改，长度可变，线程安全 StringBuilder类提供的字符串进行修改, 非同步，线程不安全 final, finally, finalize的区别？ final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码…… finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用 error和exception有什么区别? error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 Java中的异常处理机制的简单原理和应用 请查询博客 请写出你最常见到的5个runtime exception NullPointerException、ArrayIndexOutOfBoundsException、ClassCastException,ClassNotFountException, SQLException JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？ throws捕获并向外抛出异常 throw抛出异常 try catch是内部捕获异常并做自定义处理 finally是无论是否有异常都会被处理的语句，除非在finally前存在被执行的System.exit(int i)时除外 sleep()和 wait()有什么区别? sleep是让线程指定休眠时间，然后继续工作，sleep方法调用之后，并没有释放锁。使得线程仍然可以同步控制。sleep不会让出系统资源 wait则是等待，直到有线程通知notify（）唤醒他才会重新工作，释放锁 同步和异步有何异同，在什么情况下分别使用他们？举例说明。 多个线程同时取共同资源操作，一个是互相抢着用，然后彼此操作完放回，而同步是一个个线程排队。 多线程有几种实现方法?同步有几种实现方法? 多线程有两种实现方法，分别是继承Thread类与实现Runnable接口，还有Callable 同步的实现方面有两种，分别是synchronized,wait与notify，ReentrantLock 简述synchronized和java.util.concurrent.locks.Lock的异同？ 主要相同点：Lock能完成synchronized所实现的所有功能 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。 ArrayList和Vector的区别都实现list,同步性，数据的增长，性能，不一样 HashMap和Hashtable的区别 历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的值：只有HashMap可以让你将null作为一个表的条目的key或value List和 Map区别? 一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。 一个序列存储，一个键值对存储 List, Set, Map是否继承自Collection接口?List，Set是，Map不是 ArrayList,Vector, LinkedList的存储性能和特性 ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢 Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差 LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快 HashMap和HashSet的区别 HashMap实现Map接口 HashSet实现Set接口 HashMap存键值对，HashSet仅仅存储对象 HashMap是put, HashSet是add,且不可重合 Collection和 Collections的区别。 Collection是集合类的上级接口，继承与他的接口主要有Set和List. Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 字节流与字符流的区别字符流是字节流的包装，字符流则是直接接受字符串，字节是010101 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。序列化的实现：将需要被序列化的类实现Serializable接口 serialization 允许你将实现了Serializable接口的对象转换为字节序列，这些字节序列可以被完全存储以备以后重新生成原来的对象。 隐患:1.实现了序列化后，一旦发布，讲削弱改变类实现的灵活性。2.增加了bug和安全漏洞的的可能性3.当你的新版本发布时增加了相关的测试上的问题 hashmap为啥是线程不安全的?当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。 hashmap里边哪个方法导致不安全。resize()方法 java中hashmap的内部数据结构，HashMap主要是用数组来存储数据的，我们都知道它会对key进行哈希运算，哈系运算会有重复的哈希值，对于哈希值的冲突，HashMap采用链表来解决的。会对key进行hash运算，value用数组来保存在HashMap里有这样的一句属性声明： 不要在并发场景中使用HashMap 如果数据大小是固定的，那么最好给HashMap设定一个合理的容量值 equals和hashcode方法，对象之间比较，hash地址比较equals()相等的两个对象，hashcode()一定相等，equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashCode()有可能相等。 HashMap和hashTable 及ConcurrentHashMap的区别 hashMap可以接受null，不同步，速度快 hashtable不可以接受null，同步，速度慢，数据量大的时候虽然安全，但是性能越来越差 concurrentHashMap 没有以上缺点.因为维护多个table CGLIB 和 JDK生成动态代理类的区别JDK动态代理只能对实现了接口的类生成代理，而不能针对类CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法因为是继承，所以该类或方法最好不要声明成final HashMap和hashTable 及ConcurrentHashMap的区别hashMap可以接受null，不同步，速度快hashtable不可以接受null，同步，速度慢，数据量大的时候虽然安全，但是性能越来越差concurrentHashMap 没有以上缺点.因为维护多个table java.io.Serializable的用法？以及有哪些安全问题？ 实现了序列化后，一旦发布，讲削弱改变类实现的灵活性。 增加了bug和安全漏洞的的可能性 当你的新版本发布时增加了相关的测试上的问题。 java中hashmap的内部数据结构，HashMap主要是用数组来存储数据的，我们都知道它会对key进行哈希运算，哈系运算会有重复的哈希值，对于哈希值的冲突，HashMap采用链表来解决的。会对key进行hash运算，value用数组来保存在HashMap里有这样的一句属性声明： 不要在并发场景中使用HashMap 如果数据大小是固定的，那么最好给HashMap设定一个合理的容量值 什么时候该使用overload，什么时候使用override？重载和覆盖在Java里实现的都是同一个功能，但overload的输入变量不同，override则完全相同。要覆盖则override,要输入不同的变量则overload java动态绑定：程序会在运行的时候自动选择调用哪儿个方法。http://www.cnblogs.com/ericdream/archive/2012/01/07/2315697.html静态绑定：在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。java当中的方法只有final，static，private和构造方法是前期绑定后期绑定：在运行时根据具体对象的类型进行绑定。动态绑定满足三个条件： 需要有继承的存在 要有方法的重写 父类引用指向子类对象 jdk1.7的特性 java史上最大版本的一次更新： Modularization 模块化– JSR 294 或者 Project Jigsaw JVM 对动态语言的支持：指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化 更多新的 I/O APIs 即将完成，包括真正的异步I/O 和最终的真实的文件系统 file system API – JSR 203http://developer.51cto.com/art/200907/139414.htm 对XML本地语言支持. (可能的probable) Safe rethrow – 允许catch捕获语句让编译器更加聪明的知道基于什么情况下重新throw什么内容。 Null dereference expressions – Null 和 ‘?’ syntax 比较，语法类似 Groovy… 让开发者避免过多的空值验证。 更好的类型推断 Better type inference 多重捕获Multi-catch JSR 296 – Swing 应用框架 application framework – 这方面需要更简单和简洁 jdk1.8特性 函数式接口 Lambda表达式 借口的增强 集合的流式操作 等等 java.lang.Object类的几个方法 protected Object clone() 创建并返回此对象的一个副本 boolean equals(Object obj) 指示某个其他对象是否与此对象“相等” protected void finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 int hashCode() 返回该对象的哈希码值。 String toString() 返回该对象的字符串表示 Java的排序策略 冒泡法排序：那么就依次相邻两个数比较大小，然后把大（小）的数放在后面，依次类推。冒泡排序时间复杂度O(n2) 直接选择法排序：从当前数中选出一个最大或者最小的值排在最前面， 反转排序:反转数组 插入排序：依次遍历数组，假设前面已经有一部分排过序的 快速排序 堆排序 NIO AIO BIO 由上描述基本可以总结一句简短的话，同步和异步是目的，阻塞和非阻塞是实现方式。同步阻塞IO（JAVA BIO）：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 同步非阻塞IO(Java NIO) ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。 异步阻塞IO（Java NIO）：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！ （Java AIO(NIO.2)）异步非阻塞IO:在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了 ​ 多线程 immutable和mutable对象(java)如何在Java中写出Immutable的类？要写出这样的类，需要遵循以下几个原则： immutable对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象。 Immutable类的所有的属性都应该是final的。 对象必须被正确的创建，比如：对象引用在对象创建过程中不能泄露(leak)。 对象应该是final的，以此来限制子类继承父类，以避免子类改变了父类的immutable特性。 如果类中包含mutable类对象，那么返回给客户端的时候，返回该对象的一个拷贝，而不是该对象本身（该条可以归为第一条中的一个特例） 使用Immutable类的好处： Immutable对象是线程安全的，可以不用被synchronize就在并发环境中共享 Immutable对象简化了程序开发，因为它无需使用额外的锁机制就可以在线程间共享 Immutable对象提高了程序的性能，因为它减少了synchroinzed的使用 Immutable对象是可以被重复使用的，你可以将它们缓存起来重复使用，就像字符串字面量和整型数字一样。你可以使用静态工厂方法来提供类似于valueOf（）这样的方法，它可以从缓存中返回一个已经存在的Immutable对象，而不是重新创建一个。 immutable也有一个缺点就是会制造大量垃圾，由于他们不能被重用而且对于它们的使用就是”用“然后”扔“，字符串就是一个典型的例子，它会创造很多的垃圾，给垃圾收集带来很大的麻烦。当然这只是个极端的例子，合理的使用immutable对象会创造很大的价值。 什么是线程安全和非线程安全。线程安全就是说多线程访问同一代码，不会产生不确定的结果 线程有几个状态。新建状态、就绪状态、运行状态、阻塞状态及死亡状态。 新建状态(New)： 当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程 处于新生状态时，程序还没有开始运行线程中的代码 就绪状态(Runnable) 一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。 处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运 行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度的。 运行状态(Running) 当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法. 阻塞状态(Blocked) 线程运行过程中，可能由于各种原因进入阻塞状态: 1&gt;线程通过调用sleep方法进入睡眠状态； 2&gt;线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者； 3&gt;线程试图得到一个锁，而该锁正被其他线程持有； 4&gt;线程在等待某个触发条件； …… 所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。 死亡状态(Dead) 有两个原因会导致线程死亡： 1) run方法正常退出而自然死亡 2) 一个未捕获的异常终止了run方法而使线程猝死 为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级） 如何创建守护线程？使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常 什么是ThreadLocal?ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量，当前线程作为key 什么是死锁(Deadlock)？如何分析和避免死锁？死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。 避免嵌套锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，比如线程A运行R1资源，线程B运行R2资源，但是A在运行R1时又要去取R2，而B运行时R2时要取资源R1 什么是线程池？如何创建一个Java线程池？有几种创建方法一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。BlockingQueue 接口是java collections框架的一部分，它主要用于实现生产者-消费者问题 什么是Callable和Future?Java 5在concurrency包中引入了java.util.concurrent.Callable接口，它和Runnable接口很相似，但它可以返回一个对象或者抛出一个异常。 Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，我们必须等待它返回的结果。java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果 什么是FutureTask?FutureTask是Future的一个基础实现，我们可以将它同Executors使用处理异步任务。通常我们不需要使用FutureTask类，单当我们打算重写Future接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读Java FutureTask例子，学习如何使用它 什么是并发容器的实现？Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常 Executors类是什么？Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法 Thread.start ()与 Thread.run ()有什么区别？Thread.start ()方法(native)启动线程，使之进入就绪状态，当 cpu 分配时间该线程时，由 JVM 调度执行 run ()方法 Java 中多线程同步是什么？在多线程程序下，同步能控制对共享资源的访问。如果没有同步，当一个 Java 线程在修改一个共享变量时，另外一个线程正在使用或者更新同一个变量，这样容易导致程序出现错误的结果 volatile关键字在Java中有什么作用？当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的 线程之间是如何通信的？当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()\notify()\notifyAll()方法可以用于线程间通信关于资源的锁的状态。点击这里有更多关于线程wait, notify和notifyAll 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级） 多线程编程的好处是什么？在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好 你对线程优先级的理解是什么？每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级 如何确保线程安全？在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。 sychronized lock 原子类 immutable类 同步特性： 可见性 有序性 原子性 同步方法和同步块，哪个是更好的选择？同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁 ExecutorsnewFixedThreadPool。创建固定长度的线程池，每次提交任务创建一个线程，直到达到线程池的最大数量，线程池的大小不再变化。newSingleThreadExecutor。单个线程池。newCachedThreadPool。根据任务规模变动的线程池。newScheduledThreadPool。创建固定长度的线程池，以延迟或定时的方式来执行任务 12345678910111213141516171819public static void main(String[] args) &#123; ExecutorService exec = Executors.newFixedThreadPool(2); for (int i = 0; i &lt; 5; i++) exec.execute(new MyThread(i)); exec.shutdown();&#125;//----------------------------------------------------public static void main(String[] args) &#123; ExecutorService exec = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 5; i++) exec.execute(new MyThread(i)); exec.shutdown();&#125;//--------------------------------------------------------//ExecutorService executor = Executors.newCachedThreadPool()； -----------------------------------------------------------------------------//ExecutorService executor = Executors.newScheduledThreadPool(corePoolSize) ; 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。可以阅读这篇文章来了解Java的atomic类。 Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有： 可以使锁更公平 可以使线程在等待锁的时候响应中断 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 可以在不同的范围，以不同的顺序获取和释放锁 什么是Executors框架？Executor框架同java.util.concurrent.Executor 接口在Java 5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池。 什么是FutureTask?FutureTask是Future的一个基础实现，我们可以将它同Executors使用处理异步任务。通常我们不需要使用FutureTask类，但当我们打算重写Future接口的一些方法并保持原来基础的实现是，它就变得非常有用。 Java中的fork join框架是什么？fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。 出3条你遵循的多线程最佳实践 避免嵌套锁 缩小锁的范围/时间 多使用并发集合 少用wait和notify 避免使用线程组 给线程去个有意义的名字 为什么要用守护线程？进行内存回收,垃圾清理等工作，监工等 死锁 http://www.cnblogs.com/Jessy/p/3540724.html 产生死锁的四个必要条件： （1）互斥条件：一个资源每次只能被一个进程使用。（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3）不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 锁的类别有两种分法： 从数据库系统的角度来看：分为独占锁（即排它锁），共享锁和更新锁 死锁恢复 最简单，最常用的方法就是进行系统的重新启动，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程。 撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素 锁优化的思路和方法总结一下，有以下几种 http://my.oschina.net/hosee/blog/615865 减少锁持有时间 较小锁定的粒度 所分离 锁粗化 锁消除StringBuffer 为什么要使用线程池避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。http://www.roncoo.com/article/detail/126450 自旋锁的机制 自旋锁：当进程进入CPU运行时，就会给它的代码上锁，以免别的CPU中的进程修改里面的代码（不排除CPU给别的CPU上锁这样的情况，以后会讨论到。）。所谓子旋锁就是这样的一把锁：进程A进入CPU，锁上门运行，进程B来到CPU前，发现门被锁上了，于是等待进程A出来交出开锁钥匙。 互斥锁：如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的锁，直到在事务的末尾将资源上的锁释放为止。获准排他锁的事务既能读数据，又能修改数据。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊SQL——内查询示例1]]></title>
    <url>%2F2017%2F03%2F29%2F%E8%81%8A%E8%81%8ASQL%E2%80%94%E2%80%94%E5%86%85%E6%9F%A5%E8%AF%A2%E7%A4%BA%E4%BE%8B1%2F</url>
    <content type="text"><![CDATA[本文通过一个实例介绍SQL内连接查询。 建表1234567CREATE TABLE `access_data` ( `id` bigint(10) NOT NULL AUTO_INCREMENT, `name` varchar(30) DEFAULT NULL, `date` date DEFAULT NULL, `cnt` int(8) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 数据 id name date 当天访问次数 1 telinx 2017-01-05 1 2 telinx 2017-01-08 5 3 telinx 2017-02-08 3 4 telinx 2017-03-08 1 5 lonthy 2017-01-08 2 6 lonthy 2017-01-09 4 7 lonthy 2017-02-09 3 8 lonthy 2017-03-09 6 须统计数据 name month 当月总次数 当前月累计次数 lonthy 201701 6 6 lonthy 201702 3 9 lonthy 201703 6 15 telinx 201701 6 6 telinx 201702 3 9 telinx 201703 1 10 SQL查询按name,month group by 123456789SELECT A.id, A.name, DATE_FORMAT(A.date, '%Y%m')AS MONTH, SUM(A.cnt) AS cntFROM `access_data` AGROUP BY A.name, DATE_FORMAT(A.date, '%Y%m') 内连接 12345678910111213141516171819202122232425SELECT X.name, X.month, X.`cnt` '当月总次数', SUM(Y.cnt) '当前月累计次数' FROM(SELECT A.id, A.name, DATE_FORMAT(A.date, '%Y%m')AS MONTH, SUM(A.cnt) AS cntFROM `access_data` AGROUP BY A.name, DATE_FORMAT(A.date, '%Y%m') ) X INNER JOIN (SELECT B.id, B.name, DATE_FORMAT(B.date, '%Y%m')AS MONTH, SUM(B.cnt) AS cntFROM `access_data` BGROUP BY B.name, DATE_FORMAT(B.date, '%Y%m') ) Y ON X.name = Y.nameWHERE X.MONTH &gt;= Y.MONTHGROUP BY X.name, X.month]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java并发——2-定时器]]></title>
    <url>%2F2017%2F03%2F28%2F%E8%81%8A%E8%81%8AJava%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%942-%E5%AE%9A%E6%97%B6%E5%99%A8%20%2F</url>
    <content type="text"><![CDATA[当需要定时调用的功能，可以通过java的Timer类来进行定时调用实现。Timer是一个调度器,，TimerTask是需要执行的任务，TimerTask实现了run方法，具体的TimerTask需由自己实现。 12345678910111213141516171819import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123; public static void main(String[] args) &#123; new Timer().schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println("Hello World!"); &#125; &#125;, 10000, 3000);//10秒后，每隔3秒执行一次 &#125; &#125; 常用方法 延迟调度一个task，经过delay(ms)后开始进行调度，仅仅调度一次 1public void schedule(TimerTask task, long delay) 指定的时间点time上调度一次，如2017-03-28 08:08:09执行一次 1public void schedule(TimerTask task, Date time) 调度一个task，在delay（ms）后开始调度，每次调度完后，最少等待period（ms）后才开始调度 1public void schedule(TimerTask task, long delay, long period) 和上一个方法类似，唯一的区别就是传入的第二个参数为第一次调度的时间 1public void schedule(TimerTask task, Date firstTime, long period) 固定的频率来执行某项计划 12public void scheduleAtFixedRate(TimerTask task, long delay, long period)//固定的频率来执行某项计划，它不受计划执行时间的影响,到时间，任务就被执行，航班不会因你的迟到而不起飞 类似scheduleAtFixedRate 12public void scheduleAtFixedRate(TimerTask task, Date firstTime,long period)//第一次调度时间设置为一个Date时间，而不是当前时间的一个时间间隔 源码解析构造方法12345678910111213141516171819202122232425262728/** * 任务队列，存储需调度的任务 */private final TaskQueue queue = new TaskQueue();/** * 用来做独立于外部线程的调度，被Timer自己所使用的 */private final TimerThread thread = new TimerThread(queue);//构造方法1：无参构造方法，简单通过Tiemer为前缀构造一个线程名称public Timer() &#123; this("Timer-" + serialNumber());&#125;//构造方法2：传入了是否为后台线程，后台线程当且仅当进程结束时，自动注销掉public Timer(boolean isDaemon) &#123; this("Timer-" + serialNumber(), isDaemon);&#125;//设置线程名称 public Timer(String name) &#123; thread.setName(name); thread.start();&#125;//同上，不同之处为传入是否为后台线程public Timer(String name, boolean isDaemon) &#123; thread.setName(name); thread.setDaemon(isDaemon); thread.start();&#125; 常用方法123456789101112131415161718192021222324252627282930313233343536373839//通过一下常用方法的源码可以发现，都共用了方法sched(TimerTask task, long time, long period)//所以掌握了该方法也就掌握了 Timer的原理public void schedule(TimerTask task, long delay) &#123; if (delay &lt; 0) throw new IllegalArgumentException("Negative delay."); sched(task, System.currentTimeMillis()+delay, 0);&#125;public void schedule(TimerTask task, Date time) &#123; sched(task, time.getTime(), 0);&#125;public void schedule(TimerTask task, long delay, long period) &#123; if (delay &lt; 0) throw new IllegalArgumentException("Negative delay."); if (period &lt;= 0) throw new IllegalArgumentException("Non-positive period."); sched(task, System.currentTimeMillis()+delay, -period);&#125;public void schedule(TimerTask task, Date firstTime, long period) &#123; if (period &lt;= 0) throw new IllegalArgumentException("Non-positive period."); sched(task, firstTime.getTime(), -period);&#125;public void scheduleAtFixedRate(TimerTask task, long delay, long period) &#123; if (delay &lt; 0) throw new IllegalArgumentException("Negative delay."); if (period &lt;= 0) throw new IllegalArgumentException("Non-positive period."); sched(task, System.currentTimeMillis()+delay, period);&#125;public void scheduleAtFixedRate(TimerTask task, Date firstTime,long period) &#123; if (period &lt;= 0) throw new IllegalArgumentException("Non-positive period."); sched(task, firstTime.getTime(), period);&#125; 1234567891011121314151617181920212223242526//queue为一个队列，程序操作执行的时候，发生了同步，所以在timer级别，这个是线程安全的//最后将task相关的参数赋值，主要包含nextExecutionTime（下一次执行时间），//period（时间片），state（状态），然后将它放入queue队列中，做一次notify操作private void sched(TimerTask task, long time, long period) &#123; if (time &lt; 0) throw new IllegalArgumentException("Illegal execution time."); if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1)) period &gt;&gt;= 1; synchronized(queue) &#123; if (!thread.newTasksMayBeScheduled) throw new IllegalStateException("Timer already cancelled."); synchronized(task.lock) &#123; if (task.state != TimerTask.VIRGIN) throw new IllegalStateException( "Task already scheduled or cancelled"); task.nextExecutionTime = time; task.period = period; task.state = TimerTask.SCHEDULED; &#125; queue.add(task); if (queue.getMin() == task) queue.notify(); &#125;&#125;]]></content>
      <categories>
        <category>Java提升</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Java提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java并发——1-传统线程机制的回顾]]></title>
    <url>%2F2017%2F03%2F26%2F%E8%81%8A%E8%81%8AJava%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%941-%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[查看Thread类的run()方法的源代码，可以看到其实这两种方式都是在调用Thread对象的run方法，如果Thread类的run方法没有被覆盖，并且为该Thread对象设置了一个Runnable对象，该run方法会调用Runnable对象的run方法。 Thread123456789101112131415161718192021package syn;public class ThreadDemo &#123; public static void main(String[] args) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("1:" + Thread.currentThread().getName()); System.out.println("2:" + this.getName()); &#125; &#125; &#125;; thread.start(); &#125;&#125; Runnable123456789101112131415161718public class Demo &#123; public static void main(String[] args) &#123; Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("1:" + Thread.currentThread().getName()); &#125; &#125; &#125;); thread2.start(); &#125;&#125; 问题如果在Thread子类覆盖的run方法中编写了运行代码，也为Thread子类对象传递了一个Runnable对象，那么，线程运行时的执行代码是子类的run方法的代码？还是Runnable对象的run方法的代码？ 12345678910111213141516171819202122232425262728293031323334353637public class Demo &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Runnable:" + Thread.currentThread().getName()); System.out.println("Runnable:" + this.getClass().getName()); &#125; &#125;) &#123; @Override public void run() &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Thread:" + Thread.currentThread().getName()); System.out.println("Thread:" + this.getName()); &#125; &#125;; thread.start(); &#125;&#125;/**********输出：**********/Thread:Thread-0Thread:Thread-0]]></content>
      <categories>
        <category>Java提升</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Java提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Web开发——防止XSS攻击]]></title>
    <url>%2F2017%2F03%2F22%2F%E8%81%8A%E8%81%8AWeb%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E9%98%B2%E6%AD%A2XSS%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。本文主要讲述一个防止X是攻击的方案，具体实现，请看代码。 XssFilter1234567891011121314151617181920212223242526272829303132333435import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;/***防止XSS攻击，过滤HTML字符* * @author HHR* @version 0.0.1* @since */public class XssFilter implements Filter&#123; FilterConfig filterConfig = null; public void init(FilterConfig filterConfig) throws ServletException &#123; this.filterConfig = filterConfig; &#125; public void destroy() &#123; this.filterConfig = null; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; chain.doFilter(new XssHttpServletRequestWrapper( (HttpServletRequest) request), response); &#125; &#125; web.xml配置123456789101112&lt;!-- 防止XSS攻击，过滤HTML字符 --&gt;&lt;filter&gt; &lt;filter-name&gt;XssSqlFilter&lt;/filter-name&gt; &lt;filter-class&gt;cn.telinx.common.web.XssFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;XssSqlFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Web开发</tag>
        <tag>XSS攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Spring——RestTemplate的使用]]></title>
    <url>%2F2017%2F03%2F21%2F%E8%81%8A%E8%81%8ASpring%E2%80%94%E2%80%94RestTemplate%2F</url>
    <content type="text"><![CDATA[这篇文章打算介绍一下Spring的RestTemplate的使用，一个Spring已经为我们封装好了的HttpClient工具。 Spring配置文件1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns="http://www.springframework.org/schema/beans" xmlns:forest="http://api.zhizus.com/schema/forest" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://api.zhizus.com/schema/forest http://api.zhizus.com/schema/forest.xsd"&gt; &lt;context:component-scan base-package="cn.chutong" /&gt; &lt;!-- 配置RestTemplate --&gt; &lt;!--Http client Factory --&gt; &lt;bean id="httpClientFactory" class="org.springframework.http.client.SimpleClientHttpRequestFactory"&gt; &lt;property name="connectTimeout" value="$&#123;HttpClient.connectTimeout&#125;" /&gt; &lt;property name="readTimeout" value="$&#123;HttpClient.readTimeout&#125;" /&gt; &lt;/bean&gt; &lt;!--RestTemplate --&gt; &lt;bean id="restTemplate" class="org.springframework.web.client.RestTemplate"&gt; &lt;constructor-arg ref="httpClientFactory" /&gt; &lt;/bean&gt;&lt;/beans&gt; POST请求常用方法： 12345public &lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables)throws RestClientException public &lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)throws RestClientException public &lt;T&gt; T postForObject(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException Map传参12345678910public static void main(String[] args) throws Exception &#123; RestTemplate restTemplate = new RestTemplate(); Map&lt;String, Object&gt; sendMap = new HashMap&lt;String, Object&gt;(); sendMap.put("id", 40); sendMap.put("applyStatus", "3"); String url = "http://192.168.1.167:9080/bankLoan/toChangeStatus"; String respText = restTemplate.postForObject(url, sendMap, String.class); Map resMap = JSON.parseObject(respText, Map.class); logger.info("状态码statusCode=&#123;&#125;, 消息statusMessage=&#123;&#125;", resMap.get("statusCode"), resMap.get("statusMessage"));&#125; URL直接传参123456789101112public static void main(String[] args) throws Exception &#123; RestTemplate restTemplate = new RestTemplate(); String url = "http://192.168.1.167:9080/bankLoan?id=40&amp;applyStatus=3"; String respText = restTemplate.postForObject(url, null, String.class); /*或者*/ /* String url = "http://192.168.1.167:9080/bankLoan/id=&#123;&#125;&amp;applyStatus=&#123;&#125;"; String respText = restTemplate.postForObject(url, null, String.class, 40, 3); */ Map resMap = JSON.parseObject(respText, Map.class); logger.info("状态码statusCode=&#123;&#125;, 消息statusMessage=&#123;&#125;", resMap.get("statusCode"), resMap.get("statusMessage")); &#125; LinkedMultiValueMap传参1234567891011121314151617181920212223242526@Autowiredprivate RestTemplate restTemplate;public String getUserData(String key) throws Exception &#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); resultMap.put("idCardNo", key); MultiValueMap&lt;String, String&gt; urlVariables = new LinkedMultiValueMap&lt;&gt;(); urlVariables.add("key", key); /* * restTemplate获得数据 */ String response = null; try &#123; response = restTemplate.postForObject(url, urlVariables, String.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; logger.info("restTemplate获得:" + key + "--&gt;" + response); Map&lt;String, Object&gt; dataMap = JSON.parseObject(response, Map.class); dataMap = null != (Map&lt;String, Object&gt;) dataMap.get("linkedHashMap") ? (Map&lt;String, Object&gt;) dataMap.get("linkedHashMap") : (Map&lt;String, Object&gt;) dataMap.get("hashMap"); return JSON.toJSONString(dataMap);&#125; GET请求常用方法： 12345public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... urlVariables) throws RestClientException public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; urlVariables) throws RestClientExceptionpublic &lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException 常用形式： 12String url = "http://127.0.0.1/hotels/&#123;hoteNamel&#125;/order/&#123;hoterlId&#125;";String result = restTemplate.getForObject(url, String.class,"xoxo hotel", "21"); 123String url = "http://127.0.0.1/hotels/&#123;hoteNamel&#125;/order/&#123;hoterlId&#125;";Map&lt;String, String&gt; vars = Collections.singletonMap("xoxo hotel", "21");String result = restTemplate.getForObject(url, String.class, vars); 12String url = "http://127.0.0.1/hotels?name=xoxo&amp;id=21";String message = restTemplate.getForObject(url, String.class ); PUT12String url = &quot;http://127.0.0.1/hotels?name=xoxo&amp;id=21&quot;;restTemplate.put(url ,null); 参考： Spring RestTemplate介绍]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>RestTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Spring——事务管理]]></title>
    <url>%2F2017%2F03%2F21%2F%E8%81%8A%E8%81%8ASpring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[作为Java程序员，我们真的懂Spring事务管理吗？真的懂Spring事务管理的应用吗？切记不能滥用，特别不要在例如BaseServiceImpl这种类上加事务注解，因为这将影响到自身以及子类的所有public方法，无论此方法是否有对数据库有所操作。 问题什么是Spring事务管理，什么是数据库事务，Spring事务管理与数据库事务的联系？ Spring事务管理：Spring并没有事务，Spring事务通常指的是事务管理，Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。Spring事务管理本质其实就是数据库对事务的支持。 数据库事务：所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。具备ACID4个基本特征 1234begin transaction T1 update student set name='Tank' where id=2006010 delete from student where id=2006011commit ​ Spring事务管理与数据库事务的联系：本质上其实是同一个概念,spring的事务是对数据库的事务的封装，最后本质的实现还是在数据库,假如数据库不支持事务的话，spring的事务是没有作用的。数据库的事务说简单就只有开启，回滚和关闭,spring对数据库事务的包装,原理就是拿一个数据连接，根据spring的事务配置,操作这个数据连接对数据库进行事务开启,回滚或关闭操作。但是spring除了实现这些,还配合spring的传播行为对事务进行了更广泛的管理.其实这里还有个重要的点,那就是事务中涉及的隔离级别，以及spring如何对数据库的隔离级别进行封装。 事务的基本原理Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。对于纯JDBC操作数据库，想要用到事务，可以按照以下步骤进行： 获取连接 Connection con = DriverManager.getConnection() 开启事务con.setAutoCommit(true/false); 执行CRUD 提交事务/回滚事务 con.commit() / con.rollback(); 关闭连接 conn.close(); 使用Spring的事务管理功能后，我们可以不再写步骤2和4的代码，而是由Spirng 自动完成。 那么Spring是如何在我们书写的 CRUD 之前和之后开启事务和关闭事务的呢？解决这个问题，也就可以从整体上理解Spring的事务管理实现原理了。下面简单地介绍下，注解方式为例子 配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional标识。 spring 在启动的时候会去解析生成相关的bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据@Transaction的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。 真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。 Spring 事务的传播属性所谓spring事务的传播属性，就是定义在存在多个事务同时存在的时候，spring应该如何处理这些事务的行为。这些属性在TransactionDefinition中定义，具体常量的解释见下表： 常量名称 常量解释 PROPAGATION_REQUIRED 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 支持当前事务，如果当前没有事务，就抛出异常。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。 数据库隔离级别 隔离级别 隔离级别的值 导致的问题 Read-Uncommitted 0 导致脏读 Read-Committed 1 避免脏读，允许不可重复读和幻读 Repeatable-Read 2 避免脏读，不可重复读，允许幻读 Serializable 3 串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重 脏读：一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这时候回滚了，那么第二个事务就读到了脏数据。 不可重复读：一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进行了修改，这时候两次读取的数据是不一致的。 幻读：第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一个事务就会丢失对新增数据的修改。 总结： 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。 大多数的数据库默认隔离级别为 Read Commited，比如 SqlServer、Oracle 少数数据库默认隔离级别为：Repeatable Read 比如： MySQL InnoDB Spring中的隔离级别 常量 解释 ISOLATION_DEFAULT 这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。 ISOLATION_READ_UNCOMMITTED 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。 ISOLATION_READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 ISOLATION_REPEATABLE_READ 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。 ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 事务的嵌套通过上面的理论知识的铺垫，我们大致知道了数据库事务和spring事务的一些属性和特点，接下来我们通过分析一些嵌套事务的场景，来深入理解spring事务传播的机制。 假设外层事务 Service A 的 Method A() 调用 内层Service B 的 Method B() PROPAGATION_REQUIRED(spring 默认) 如果ServiceB.methodB() 的事务级别定义为 PROPAGATION_REQUIRED，那么执行 ServiceA.methodA() 的时候spring已经起了事务，这时调用 ServiceB.methodB()，ServiceB.methodB() 看到自己已经运行在 ServiceA.methodA() 的事务内部，就不再起新的事务。 假如 ServiceB.methodB() 运行的时候发现自己没有在事务中，他就会为自己分配一个事务。 这样，在 ServiceA.methodA() 或者在 ServiceB.methodB() 内的任何地方出现异常，事务都会被回滚。 PROPAGATION_REQUIRES_NEW 比如我们设计 ServiceA.methodA() 的事务级别为 PROPAGATION_REQUIRED，ServiceB.methodB() 的事务级别为 PROPAGATION_REQUIRES_NEW。 那么当执行到 ServiceB.methodB() 的时候，ServiceA.methodA() 所在的事务就会挂起，ServiceB.methodB() 会起一个新的事务，等待 ServiceB.methodB() 的事务完成以后，它才继续执行。 他与 PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为 ServiceB.methodB() 是新起一个事务，那么就是存在两个不同的事务。如果 ServiceB.methodB() 已经提交，那么 ServiceA.methodA() 失败回滚，ServiceB.methodB() 是不会回滚的。如果 ServiceB.methodB() 失败回滚，如果他抛出的异常被 ServiceA.methodA() 捕获，ServiceA.methodA() 事务仍然可能提交(主要看B抛出的异常是不是A会回滚的异常)。 PROPAGATION_SUPPORTS 假设ServiceB.methodB() 的事务级别为 PROPAGATION_SUPPORTS，那么当执行到ServiceB.methodB()时，如果发现ServiceA.methodA()已经开启了一个事务，则加入当前的事务，如果发现ServiceA.methodA()没有开启事务，则自己也不开启事务。这种时候，内部方法的事务性完全依赖于最外层的事务。 PROPAGATION_NESTED 现在的情况就变得比较复杂了, ServiceB.methodB() 的事务属性被配置为 PROPAGATION_NESTED, 此时两者之间又将如何协作呢?ServiceB#methodB 如果 rollback, 那么内部事务(即 ServiceB#methodB) 将回滚到它执行前的 SavePoint 而外部事务(即 ServiceA#methodA) 可以有以下两种处理方式: a、捕获异常，执行异常分支逻辑 这种方式也是嵌套事务最有价值的地方, 它起到了分支执行的效果, 如果 ServiceB.methodB 失败, 那么执行 ServiceC.methodC(), 而 ServiceB.methodB 已经回滚到它执行之前的 SavePoint, 所以不会产生脏数据(相当于此方法从未执行过), 这种特性可以用在某些特殊的业务中, 而 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 都没有办法做到这一点。 b、 外部事务回滚/提交 代码不做任何修改, 那么如果内部事务(ServiceB#methodB) rollback, 那么首先 ServiceB.methodB 回滚到它执行之前的 SavePoint(在任何情况下都会如此), 外部事务(即 ServiceA#methodA) 将根据具体的配置决定自己是 commit 还是 rollback 另外三种事务传播属性基本用不到，在此不做分析。 总结对于项目中需要使用到事务的地方，我建议开发者还是使用spring的TransactionCallback接口来实现事务，不要盲目使用spring事务注解，如果一定要使用注解，那么一定要对spring事务的传播机制和隔离级别有个详细的了解，否则很可能发生意想不到的效果。 另外注意： 注解是 能继承 的， 能继承 能继承 能继承 ！有的文章误人子弟不如自己看源码！ 不要在任何接口/接口方法上加事务注解，不要在任何接口/接口方法上加事务注解！没用的。 本文转自码农网 – 吴极心原创 连接地址：http://www.codeceo.com/article/spring-transactions.html 另推荐文章Spring 事务管理原理探究]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Web开发——简单的验证码实现方式]]></title>
    <url>%2F2017%2F03%2F19%2F%E8%81%8A%E8%81%8AWeb%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文主要讲述一个简单实现登录验证码实现方式，具体实现，请看代码。 生成验证码图片ValidateCodeServlet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package cn.chutong.common.web;import java.awt.Color;import java.awt.Font;import java.awt.Graphics2D;import java.awt.image.BufferedImage;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class ValidateCodeServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; // 验证码图片的宽度。 private int width = 80; // 验证码图片的高度。 private int height = 25; // 验证码字符个数 private int codeCount = 4; private int x = 0; // 字体高度 private int fontHeight; private int codeY; char[] codeSequence = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '2', '3', '4', '5', '6', '7', '8', '9' &#125;; // 去掉'O','0','o','l','1' /** * 初始化验证图片属性 */ public void init() throws ServletException &#123; // 从web.xml中获取初始信息 // 宽度 String strWidth = this.getInitParameter("width"); // 高度 String strHeight = this.getInitParameter("height"); // 字符个数 String strCodeCount = this.getInitParameter("codeCount"); // 将配置的信息转换成数值 try &#123; if (strWidth != null &amp;&amp; strWidth.length() != 0) &#123; width = Integer.parseInt(strWidth); &#125; if (strHeight != null &amp;&amp; strHeight.length() != 0) &#123; height = Integer.parseInt(strHeight); &#125; if (strCodeCount != null &amp;&amp; strCodeCount.length() != 0) &#123; codeCount = Integer.parseInt(strCodeCount); &#125; &#125; catch (NumberFormatException e) &#123; &#125; x = width / (codeCount + 1); fontHeight = height - 2; codeY = height - 4; &#125; protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, java.io.IOException &#123; // 定义图像buffer BufferedImage buffImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics2D g = buffImg.createGraphics(); // 创建一个随机数生成器类 Random random = new Random(); // 将图像填充为白色 g.setColor(Color.WHITE); g.fillRect(0, 0, width, height); // 创建字体，字体的大小应该根据图片的高度来定。 Font font = new Font("Fixedsys", Font.PLAIN, fontHeight); // 设置字体。 g.setFont(font); // 画边框。 g.setColor(Color.BLACK); g.drawRect(0, 0, width - 1, height - 1); // 随机产生10条干扰线，使图象中的认证码不易被其它程序探测到。 g.setColor(Color.DARK_GRAY); for (int i = 0; i &lt; 10; i++) &#123; int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(8); int yl = random.nextInt(8); g.drawLine(x, y, x + xl, y + yl); &#125; // randomCode用于保存随机产生的验证码，以便用户登录后进行验证。 StringBuffer randomCode = new StringBuffer(); int red = 0, green = 0, blue = 0; // 随机产生codeCount数字的验证码。 for (int i = 0; i &lt; codeCount; i++) &#123; // 得到随机产生的验证码数字。 String strRand = String.valueOf(codeSequence[random.nextInt(57)]); // 产生随机的颜色分量来构造颜色值，这样输出的每位数字的颜色值都将不同。 red = random.nextInt(150); green = random.nextInt(150); blue = random.nextInt(150); // red = 110; // green = 220; // blue = 110; // 用随机产生的颜色将验证码绘制到图像中。 g.setColor(new Color(red, green, blue)); g.drawString(strRand, (i + 1) * x - 8, codeY); // 将产生的四个随机数组合在一起。 randomCode.append(strRand); &#125; // 将四位数字的验证码保存到Session中。 HttpSession session = req.getSession(); session.setAttribute("validateCode", randomCode.toString()); // 禁止图像缓存。 resp.setHeader("Pragma", "no-cache"); resp.setHeader("Cache-Control", "no-cache"); resp.setDateHeader("Expires", 0); resp.setContentType("image/jpeg"); // 将图像输出到Servlet输出流中。 ServletOutputStream sos = resp.getOutputStream(); ImageIO.write(buffImg, "jpeg", sos); sos.close(); &#125;&#125; web.xml配置12345678910&lt;!-- 登录页面图形验证码 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;validateCodeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.chutong.common.web.ValidateCodeServlet&lt;/servlet-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;validateCodeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ValidateCodeServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 验证码页面代码1234567&lt;div class="input-group mt20"&gt; &lt;div class="input-group-addon"&gt;验证码&amp;nbsp;&lt;/div&gt; &lt;input type="text" class="form-control" name="validateCode" id="validateCode" placeholder="请输入验证码"&gt; &lt;div class="input-group-addon input-code"&gt; &lt;img style="cursor:pointer" id="authCodeImg" alt="验证码" src="&lt;%=basePath%&gt;/servlet/ValidateCodeServlet" align="absmiddle" height="32" /&gt; &lt;/div&gt;&lt;/div&gt; 验证码js脚本代码12345$(function()&#123; $("#authCodeImg").click(function() &#123; $("#authCodeImg").attr("src",chgUrl(contextPath+"/servlet/ValidateCodeServlet"));&#125;);&#125;) 登录校验验证码123456789101112131415161718192021222324@RequestMapping(value = "/login", method = &#123; RequestMethod.GET, RequestMethod.POST &#125;)public String login(HttpServletRequest request, ModelMap modelMap) &#123; String validateCode = request.getParameter("validateCode"); if (!validate(request, validateCode)) &#123; returnMap.put("success", "false"); returnMap.put("message", "验证码不正确"); &#125; return "main"; &#125;private boolean validate(HttpServletRequest request, String validateCode) &#123; HttpSession session = request.getSession(); Object validateCode_o = session.getAttribute("validateCode"); if (validateCode_o != null) &#123; String validateCode_str = validateCode_o.toString().trim(); if (validateCode_str.equalsIgnoreCase(validateCode)) &#123; return true; &#125; &#125; return false;&#125; 附图：]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——异常机制]]></title>
    <url>%2F2017%2F03%2F18%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[在开发中，我们经常需要对代码进行try{}catch{}finally{}。用了这么多，我们真的很懂异常吗？懂了是不是可以自己创建自己的异常呢？本文将通过一个代码案例慢慢引申到jre的异常机制。 一个案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.telinx.demo;public class ExceptionDemo &#123; public ExceptionDemo() &#123;&#125; @SuppressWarnings("finally") boolean execute() throws Exception &#123; boolean result = true; try &#123; result = execute1(); &#125; catch (Exception e) &#123; System.out.println("execute, catch exception"); result = false; throw e; &#125; finally &#123; System.out.println("execute, finally; return value=" + result); return result; &#125; &#125; @SuppressWarnings("finally") boolean execute1() throws Exception &#123; boolean result = true; try &#123; result = execute2(); if (!result) &#123; return false; &#125; System.out.println("execute1, at the end of try"); return result; &#125; catch (Exception e) &#123; System.out.println("execute1, catch exception"); result = false; throw e; &#125; finally &#123; System.out.println("execute1, finally; return value=" + result); return result; &#125; &#125; @SuppressWarnings("finally") boolean execute2() throws Exception &#123; boolean result = true; try &#123; int b = 12; int c; for (int i = 2; i &gt;= -2; i--) &#123; c = b / i; System.out.println("i=" + i); &#125; return true; &#125; catch (Exception e) &#123; System.out.println("execute2, catch exception"); result = false; throw e; &#125; finally &#123; System.out.println("execute2, finally; return value=" + result); return result; &#125; &#125; public static void main(String[] args) &#123; ExceptionDemo executeception1 = new ExceptionDemo(); try &#123; executeception1.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;/********输出：*******//*i=2i=1execute2, catch exceptionexecute2, finally; return value=falseexecute1, finally; return value=falseexecute, finally; return value=false*//*解释：1.execute2方法执行已将异常捕获输出“execute2, catch exception”2.execute2执行finally块输出“execute2, finally; return value=false”3.execute1并没发生异常（execute2已经捕获），执行finally输出“execute1, finally; return value=false”4.execute没有异常发生（execute2已经捕获），执行finally输出“execute, finally; return value=false” finally是一定会执行的，finally一定要慎用，建议看看《effective Java》关于finally的内容*/ Java异常体系简述Java语言中异常分为运行时异常（Exception）和编译型异常（Error），NullPointerException(空指针异常)、ClassNotFoundException、IndexOutOfBoundsException等。Java通过API中Throwable类的众多子类描述各种不同的异常。 Java异常都是对象，是Throwable子类的实例。 Java异常类结构图： 在 Java 中，所有的异常都是Throwable的子子孙孙，Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。 Throwable： 重要的继承子类有Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类 Error：是程序无法处理的错误，表示运行应用程序中较严重问题。Error表示代码运行时 JVM（Java 虚拟机）出现的问题，如Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时（I/O打开了资源却没有关闭），出现 OutOfMemoryError。这是Error将导致JVM终止运行。 Exception：是程序本身可以处理的异常，如RuntimeException 类及其子类表示因“JVM 常用操作”引发的错误，这些失误包括了我们常见的NullPointerException（对空对象引用且操作）、ArrayIndexOutOfBoundException（数组越界，数组长度并不没有我们编写代码获取的长度） 异常和错误的区别：异常能被程序本身可以处理，错误是无法处理 异常分类java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常 可查的异常可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。 这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。 可查的异常亦可认为是非运行时异常 。 不可查异常:不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。 运行时异常都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择try{}catch{}，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。 处理异常机制Java应用程序中，异常处理机制有2种，分别为为：抛出异常，捕捉异常。对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。一个异常总是先被抛出，后被捕捉的。 抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。 Java程序中,throw关键字是抛出异常，而throws是捕获并抛出。 捕捉异常： 由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。但事实上严格来说，有异常是不能放任不管的，故我们需捕获异常，且须对其处理，也许不能准确处理，但至少能暴露更多有利于我们解决异常的信息根据。 try{}catch{} 12345try &#123; executeception1.execute();// 可能会发生异常的程序代码 &#125; catch (Exception e) &#123; e.printStackTrace();// 捕获并处置try抛出的异常类型Exception&#125; try{}catch{}finally{} 1234567891011121314151617try &#123; // 可能会发生异常的程序代码 &#125; catch (Exception e) &#123; // 捕获并处理try抛出的异常类型Exception &#125; finally &#123; // 无论是否发生异常，都将执行的语句块 &#125; /*try-catch-finally 规则(异常处理语句的语法规则）：1) 必须在try之后添加catch或finally块。try块后可同时接catch和finally块，但至少有一个块。2) 必须遵循块顺序：若代码同时使用catch和finally块，则必须将catch块放在try块之后。3) catch块与相应的异常类的类型相关。4) 一个try块可能有多个catch块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块5) 可嵌套try-catch-finally结构。6) 在try-catch-finally结构中，可重新抛出异常。7) 除了下列情况，总将执行finally做为结束：JVM 过早终止（调用 System.exit(int)）；在 finally 块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击*/ 常见异常在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类: RuntimeException： 异常名称 异常描述 ArithmeticException 算术条件异常 ArrayIndexOutOfBoundsException 数组索引越界异常 NullPointerException 空指针异常 ClassNotFoundException 找不到类异常 IllegalArgumentException 非法参数异常 IOException： 异常名称 异常描述 IOException 操作输入流和输出流时可能出现的异常 EOFException 文件已结束异常 FileNotFoundException 文件未找到异常 其他： 异常名称 异常描述 ClassCastException 类型转换异常类 ArrayStoreException 数组中包含不兼容的值抛出的异常 SQLException 操作数据库异常类 NoSuchFieldException 字段未找到异常 NoSuchMethodException 方法未找到抛出的异常 NumberFormatException 字符串转换为数字抛出的异常 StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常 IllegalAccessException 不允许访问某类异常 使用异常总结 尽量使用finally块去释放占用资源 尽量处理异常，而不只是简单的输出异常 如何处理异常，根据业务需求而定 不能确保业务逻辑是否正常运行，加上try-catch，处理潜在异常 避免过大的try块，不要把不会出现异常的代码放到try块里面，尽量保持一个try块对应一个或多个异常。 细化异常的类型，不要不管什么类型的异常都写成Excetpion 尽量不要将try…catch写在循环中 参考： Java常见异常总结 深入理解java异常处理机制 Java之美从菜鸟到高手演变]之Exception 为什么不建议用 try catch Try-Catch真的会影响程序性能吗 java源码分析（7）-Throwable]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Mysql——SQL优化、慢查询、配置优化]]></title>
    <url>%2F2017%2F03%2F14%2F%E8%81%8A%E8%81%8AMysql%E2%80%94%E2%80%94SQL%E4%BC%98%E5%8C%96%E5%8F%8A%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[SQL优化是程序员老生常谈的事情，也是一个不可避免需要处理的事情，当系统性能得到一个瓶颈，优化SQL或许是一种让系统再次飞起的策略，可能效果不是很明显，但更多的细微优化，性能也随之提升。对数据库操作的慢查询是让程序员很头疼的事情，怎么样才能让慢查询变得不是那么慢呢？本文将讲述SQL优化的几种策略，以及SQL优化后针对慢查询再次改善的方案。 常用SQL优化策略利用索引对查询进行优化，要尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。 避免null值条件查询应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描 12345select name, id_card from data wher bank_card is null;/*最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库*//*备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL*//*可以在num数值型上设置默认值0，确保表中num数值型列没有null值，然后这样查询*/select name, id_card from data wher age=0; 避免在 where 子句中使用 != 或 &lt;&gt; 操作符尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描 避免在 where 子句中使用 or 来连接条尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如： 12345select name, id_card from data wher id_card='24512121212X' or name='钟XX';/*可以优化为*/select name, id_card from data wher id_card='24512121212X'union allselect name, id_card from data wher name='钟XX'; in 和 not in 也要慎用,尽量使用Existin 和 not in 也要慎用，否则会导致全表扫描，如： 12345678select id from data where age in(11,12,33);/*对于这种连续的值，可优化为*/select id from data where age between 1 and 3;/*实情没那么多连续的情况，可用exist代替in*/select id from data where id_card in (select id_card from user where name like '刘%');/*优化如下*/select id from data A where exist (select id_card from user B where name like '刘%' and A.id_card=B.id_card); 尽量避免使用like ‘%XXX%’使用like ‘%XXX%’将导致全表扫描 1select id_card from user where name like '%abc%' 避免在 where 子句中对字段进行表达式操作123select id_card from user where age/2=12;/*优化如下*/select id_card from user where age=24; 尽量避免在where子句中对字段进行函数操作尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表 12345select id from data where substring(name,1,3) = ’xyz’; /*-–name以abc开头的id*/select id from data where datediff(day,create_at,’2016-11-30′) = 0 ; /*---生成的id*//**优化：**/select id from data where substring(name,1,3) like ’xyz%’; /*-–name以abc开头的id*/select id from data where create_at &gt;= '2016-11-30' and create_at &lt; '2016-12-30' ####避免select count(*) from select count(*) from data，这样不带任何条件的count会引起全表扫描，并且没有任何业务意义 索引并不是越多越好索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 避免使用游标，因为游标的效率较差避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 ####避免长时间锁表 拆分大的 DELETE 或INSERT 语句，批量提交SQL语句时，要避免你的操作让你的整个网站停止。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。当锁表时间太长，导致线程大量积累，一旦开启操作，服务器或许立马就挂了。 所以当执行大批量的 DELETE 或INSERT 语句，应当分批的执行，然后每执行完一小批则sleep一会放其他线程执行，或者如此操作放在服务器闲时操作。 ####选择一个正确的存储引擎 在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。 MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至update一个字段，当前表表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。此外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。 InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。 分割表分割表可分为水平分割表和垂直分割表两种，优先考虑垂直分割表，且对于考虑分割表要慎重，不到万不得已也就不要去分割了。 垂直分割是对于一个列很多的表，若某些列的访问频率远远高于其它列，就可以将主键和这些列作为一个表，将主键和其它列作为另外一个表。通过减少列的宽度，增加了每个数据页的行数，一次I/O就可以扫描更多的行，从而提高了访问每一个表的速度。但是由于造成了多表连接，所以应该在同时查询或更新不同分割表中的列的情况比较少的情况下使用。 水平分割是按照行将一个表分割为多个表，这可以提高每个表的查询速度，但查询、更新时要选择不同的表，统计时要汇总多个表，因此应用程序会更复杂。 慢查询解决方案开启慢查询日志开启1234在my.cnf或者my.ini中添加log-queries-not-using-indexes参数，表示记录下没有使用索引的查询。log-slow-queries=/data/mysqldata/slow-query.log long_query_time=10 log-queries-not-using-indexes 慢查询分析mysqldumpslow… 其他 上述SQL优化策略 加缓存，memcached,redis 主从复制或主主复制，读写分离， 应用层读写分离，效率高， 第三方工具，如360的atlas， 读的数据库可切换为MyISAM 引擎 分割表 ###explain分析查询 使用 EXPLAIN 关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。通过explain命令可以得到: 表的读取顺序 数据读取操作的操作类型 哪些索引可以使用 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询 具体查看“聊聊Mysql——explain” 配置优化可参考mysql性能优化-慢查询分析、优化索引和配置 ，该文章对配置做了很详细的说明。 参考： mysql性能优化-慢查询分析、优化索引和配置 数据库性能优化策略 数据库SQL优化大总结之 百万级数据库优化方案]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Mysql——explain]]></title>
    <url>%2F2017%2F03%2F12%2F%E8%81%8A%E8%81%8AMysql%E2%80%94%E2%80%94explian%2F</url>
    <content type="text"><![CDATA[explain显示了MySQL如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。 ###id id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表是这是一个结果集，不需要使用它来进行查询。 select_type simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个 primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个 union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响 union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响 derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select table显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的，与类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。 type[重点]很重要的列之一，显示连接使用的类型，按最优到最差的类型排序：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引。 system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描 eq_ref：除 const 类型外最好的可能实现的连接类型，它用在一个索引的所有部分被连接使用并且索引是 UNIQUE 或 PRIMARY KEY，对于每个索引键，表中只有一条记录与之匹配 ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。 fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引 ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多 unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值 index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重 range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中 index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range index：全表扫描，只是扫描表的时候按照索引次序进行而不是行。主要优点是避免了排序，但是开销仍然非常大 all：最坏的情况，从头到尾全表扫描 ###possible_keys 查询可能使用到的索引都会在这里列出来 key查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。 key_len用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。 ref如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func。 rows这里是执行计划中估算的扫描行数，不是精确值 extra这个列可以显示的信息非常多，有几十种，常用的有 distinct：在select部分使用了distinc关键字 no tables used：不带from字句的查询或者From dual查询 使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。 using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中 using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。 using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。 using sort_union，using_union，using intersect，using sort_intersection： using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集 using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集 using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。 using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。 using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个 loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个 ​ 参考： mysql explain执行计划详解]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——Http通讯加密方案]]></title>
    <url>%2F2017%2F03%2F10%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94Http%E5%8D%8F%E8%AE%AE%E9%80%9A%E8%AE%AF%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[因为信息安全的需要，网络通讯安全一直是一个备受关注的话题。但很多时候编写一些简单的网络通讯把这标准加密应用添加进来乎一下子把程序变得复杂了，而实现自己的加密算法那就更加不可取；其实通过一些现有的加密的技术应用完全可以实现即简单又安全的网络通讯程序。在保证网络通讯安之前全，要确保连接的有效性，然后是保证内容即使被人抓取也无法获取确切的信息。下文主要讲解了一种实现Http通讯加密方案的实现。 主流的加密方式对称加密对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.demo.util;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;public class Des &#123; /** * &lt;p&gt; * 生成对称密钥 * &lt;/p&gt; * * @return * @throws Exception */ public static SecretKey getSymmetricKey() throws Exception &#123; //密钥生成器 KeyGenerator key=KeyGenerator.getInstance("DESede"); /**初始化密钥生成器 * 该步骤一般指定密钥的长度。如果该步骤省略的话， * 会根据算法自动使用默认的密钥长度。指定长度时， * 若第一步密钥生成器使用的是“DES”算法，则密钥长度必须是56位； * 若是“DESede”，则可以是112或168位，其中112位有效；若是“AES”， * 可以是128, 192或256位；若是“Blowfish”，则可以是32至448之间可以被8整除的数； * “HmacMD5”和“HmacSHA1”默认的密钥长度都是64个字节 */ key.init(168); //生成密钥 SecretKey secret=key.generateKey(); return secret; &#125; /** * &lt;p&gt; * 对称密钥加密 * &lt;/p&gt; * * @return * @throws Exception */ public static byte[] encryptBySymmetricKey(byte[] data, SecretKey secret) throws Exception &#123; Cipher cp=Cipher.getInstance("DESede"); //初始化cipher ENCRYPT_MODE表示加密DECRYPT_MODE解密 后面一个参数是密钥 cp.init(Cipher.ENCRYPT_MODE, secret); //对字节码机密 miby就是加密后的字节码 byte[] miby=cp.doFinal(data); //获取密文字符串 return miby; &#125; /** * &lt;p&gt; * 对称密钥解密 * &lt;/p&gt; * * @return * @throws Exception */ public static byte[] decryptBySymmetricKey(byte[] encryptedData, SecretKey secret) throws Exception &#123; //工厂模式获取Cipher实例 密码器 Cipher cp=Cipher.getInstance("DESede"); //初始化cipher ENCRYPT_MODE表示加密DECRYPT_MODE解密 后面一个参数是密钥 cp.init(Cipher.DECRYPT_MODE, secret); //对密文字节码进行解密 如果密码写入文件可以使用文件流读写成一个数组 byte[] miby=cp.doFinal(encryptedData); return miby; &#125; public static void main(String[] args) throws Exception &#123; SecretKey secret = getSymmetricKey(); String str = "telinx1991"; byte[] data = str.getBytes("UTF-8"); String encryptText = Base64.encode(encryptBySymmetricKey(data, secret)); System.out.println(encryptText); byte[] decryptText = decryptBySymmetricKey(Base64.decode(encryptText), secret); String decryptStr=new String(decryptText,"utf-8"); System.out.println(decryptStr); &#125;&#125;//输出aM/HaLFYhvDDOvHVKDSQdw==telinx1991 对称加密的最大缺点是密钥的管理与分配，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。 非对称加密非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥：公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。 非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。目前最常用的非对称加密算法是RSA算法，是Rivest, Shamir, 和Adleman于1978年发明，他们那时都是在MIT。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208package com.demo.util;import java.io.ByteArrayOutputStream;import java.security.Key;import java.security.KeyFactory;import java.security.PrivateKey;import java.security.PublicKey;import java.security.Signature;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import javax.crypto.Cipher;import com.demo.constant.Consts;public class RSADemo &#123; /** * 加密算法RSA */ public static final String KEY_ALGORITHM = "RSA"; /** */ /** * 签名算法 */ public static final String SIGNATURE_ALGORITHM = "MD5withRSA"; /** */ /** * 获取公钥的key */ private static final String PUBLIC_KEY = "RSAPublicKey"; /** */ /** * 获取私钥的key */ private static final String PRIVATE_KEY = "RSAPrivateKey"; /** */ /** * RSA最大加密明文大小 */ private static final int MAX_ENCRYPT_BLOCK = 117; /** */ /** * RSA最大解密密文大小 */ private static final int MAX_DECRYPT_BLOCK = 128; /** * &lt;p&gt; * 公钥解密 * &lt;/p&gt; * * @param encryptedData * 已加密数据 * @param publicKey * 公钥(BASE64编码) * @return * @throws Exception */ public static byte[] decryptByPublicKey(byte[] encryptedData, String publicKey) throws Exception &#123; byte[] keyBytes = Base64.decode(publicKey); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, publicK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125; /** * &lt;p&gt; * 用私钥对信息生成数字签名 * &lt;/p&gt; * * @param data * 已加密数据 * @param privateKey * 私钥(BASE64编码) * * @return * @throws Exception */ public static String sign(byte[] data, String privateKey) throws Exception &#123; byte[] keyBytes = Base64.decode(privateKey); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PrivateKey privateK = keyFactory.generatePrivate(pkcs8KeySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initSign(privateK); signature.update(data); return Base64.encode(signature.sign()); &#125; /** * &lt;p&gt; * 校验数字签名 * &lt;/p&gt; * * @param data * 已加密数据 * @param publicKey * 公钥(BASE64编码) * @param sign * 数字签名 * * @return * @throws Exception * */ public static boolean verify(byte[] data, String publicKey, String sign) throws Exception &#123; byte[] keyBytes = Base64.decode(publicKey); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PublicKey publicK = keyFactory.generatePublic(keySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initVerify(publicK); signature.update(data); return signature.verify(Base64.decode(sign)); &#125; /** * &lt;P&gt; * 私钥解密 * &lt;/p&gt; * * @param encryptedData * 已加密数据 * @param privateKey * 私钥(BASE64编码) * @return * @throws Exception */ public static byte[] decryptByPrivateKey(byte[] encryptedData, String privateKey) throws Exception &#123; byte[] keyBytes = Base64.decode(privateKey); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125; public static void main(String[] args) throws Exception &#123; /* * 加密解密 */ String content = "telinx1991"; String encryptSymmetricKey = Base64.encode(RSAUtils.encryptByPublicKey(content.getBytes(), Consts.TEST_PUBLIC_KEY)); System.out.println(encryptSymmetricKey); byte[] encoded = RSAUtils.decryptByPrivateKey(Base64.decode(encryptSymmetricKey), Consts.TEST_PRIVATE_KEY); String decryptTxt = new String(encoded, "UTF-8"); System.out.println(decryptTxt); /* * 签名验签 */ String signData = RSAUtils.sign(encryptSymmetricKey.getBytes("UTF-8"), Consts.TEST_PRIVATE_KEY); boolean verify = RSAUtils.verify(encryptSymmetricKey.getBytes("UTF-8"), Consts.TEST_PUBLIC_KEY, signData); System.out.println("verify--&gt;" + verify); &#125;&#125;//输出JnVE8ZFAo/gphPI3PZok8PQGWfBEtIdUzCGDpKApiXNNBpCq8mATCkFNLQri9iT6wRSrr6Di7X33DxR0GaAgsn1SqgGRcItssjNXFTXOQlTxnlz8q525OS/TAq3Lj+InIyqyHoCSnxQPcvGoCTtuYbJ9CKPP8XO5rkP8fg0GUoE=telinx1991verify--&gt;true 虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。 Http通讯加密方案通过上述大致了解了两种的加密方式的优劣，所以对称加密结合非对称加密，安全且高效，具体实施方案如下： 实现代码：demo 参考： 对称加密与非对称加密]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Spring——常用注解]]></title>
    <url>%2F2017%2F03%2F08%2F%E8%81%8A%E8%81%8ASpring%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[spring的注解很多，之前一篇讲述的是Spring注解的原理，本文主要是整理了常用注解的用法。 类级别的注解@Component指组件，当组件不好归类的时候，我们可以使用这个注解进行标注，不建议使用 @Repository用于标注数据访问组件，@Repository默认bean名称是类名（头字母小写) @Repository(“userDao”) @Controller用于标注控制层组件 @Service用于标注业务层组件,@Service默认名称是类名（头字母小写),@Service(“xxx”)这样来指定bean名称，也可以与@Qualifier相结合使用 @ManagedBean其和@Component完全相同，唯一不同的就是名字和创建者（一个是Spring，一个是Java EE规范） @Named不仅可以用于依赖注入来指定注入的Bean的标识符，还可以用于定义Bean。即注解在类型上表示定义Bean，注解在非类型上（如字段）表示指定依赖注入的Bean标识符 @Lazy表示延迟初始化,@Lazy(true) @Scope用于指定scope作用域的（用在类上）,@Scope(“prototype”) 类内部的注解@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用 @Resource装配bean，默认安照名称进行装配，如果name属性一旦指定，就只会按照名称进行装配 @Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配 指定了name或者type则根据指定的类型去匹配bean 指定了name和type则根据指定的name和type去匹配bean，任何一个不匹配都将报错 @Resource(name=”userService”) @Value获取properties文件中的配置值,@Value(“${db.name}”) @Qualifier使用@Autowired 时，如果找到多个同一类型的bean，则会抛异常，此时可以使用 @Qualifier(“beanName”)，明确指定bean的名称进行注入，此时与 @Resource指定name属性作用相同。 @RequestMapping完成 Request 请求到处理器或处理器方法的映射 @RequestMapping (“/user”) @RequestMapping (value= “testParams”, params={“param1=value1”, “param2”, “!param3” }) params属性用于指定请求参数，用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在,只有当请求是/testParams.do并且满足指定的三个参数条件的时候才能访问到testParams方法；故请求/testParams.do?param1=value1&amp;param2=value2 能够正确访问到该testParams 方法；请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 不能够正常的访问到该方法，因含param3参数，与规定不符合 @RequestMapping (value= “testMethod”, method={RequestMethod.GET, RequestMethod.DELETE }) method 属性主要是用于限制能够访问方法的请求类型 @RequestMapping (value= “testHeaders” , headers={“host=localhost”, “Accept”}) 使用headers属性可以通过请求头信息来缩小@RequestMapping 的映射范围 @RequestParam使用 @RequestParam 可完成 HttpServletRequest 的请求参数到控制器方法参数的绑定，同时还可增加一些参数的选项。 public String userInfo( @RequestParam(value=”name”,required=true) String name) 会把HttpServletRequest请求中的参数name绑定到控制器方法userInfo的参数name，同时指定name参数为必选参数。 @PathVariableURI 模板就是在URI 中给定一个变量，然后在映射的时候动态的给该变量赋值 @RequestMapping ( “/showView/{variable2}” ) public ModelAndView showView( @PathVariable String variable1, @PathVariabl(“variable2”) int variable2) @PostConstruct用于指定初始化方法（用在方法上） @PreDestroy用于指定销毁方法（用在方法上） @ModelAttribute被@ModelAttribute注释的方法会在此controller每个方法执行前被执行，因此对于一个controller映射多个URL的用法来说，要谨慎使用 1234@ModelAttribute public void getSo(@RequestParam String xyz, Model model) &#123; model.addAttribute("attributeName", xyz); &#125; 12345@PutMapping("/accounts/&#123;account&#125;")public String save(@ModelAttribute("account") Account account) &#123; /*......*/&#125; @SessionAttributes有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性 1234@SessionAttributes("currUser") // 将ModelMap 中属性名为currUser 的属性@SessionAttributes(&#123;"attr1","attr2"&#125;) @SessionAttributes(types = User.class) @SessionAttributes(types = &#123;User.class,Dept.class&#125;) @SessionAttributes(types = &#123;User.class,Dept.class&#125;,value=&#123;"attr1","attr2"&#125;) @Required见@RequestParamm,负责检查功能 @CookieValue@RequestMapping ( “test” ) public String getCookieValue( @CookieValue (“hello”) String cookieValue, @CookieValue String hello) 使用@CookieValue完成了把名为hello的cookie的值绑定控制器方法getCookieValue的参数 cookieValue上；后一个没有指定名称时，默认自动查找同名的cookie的值绑定到getCookieValue的参数hello上 @RequestHeader@RequestMapping ( “/test” ) public String getRequestHeader( @RequestHeader(“Host”) String hostAddr, @RequestHeader String Host, @RequestHeader String host )使用 @RequestHeader 注解可绑定 HttpServletRequest 请求的某个头信息到 Controller 方法的参数 @ResponseBody将内容或对象作为 HTTP 响应正文返回，并调用适合HttpMessageConverter的Adapter转换对象，写入输出流。 HttpMessageConverter接口，需要在Spring配置文件中开启 @Cacheable声明一个方法的返回值应该被缓存：@Cacheable(modelId = “testCaching”) @CacheFlush声明一个方法是清空缓存的触发器：@CacheFlush(modelId = “testCaching”) @Transaction事务注解要使用Spring3事务管理，要在applicationContext.xml增加事务管理器相关配置信息 12&lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" p:dataSource-ref="dataSource"&gt; &lt;/bean&gt; @Transactional注解可以标注在类和方法上 在方法上的@Transactional注解会覆盖掉类上的@Transactional]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——自定义异常]]></title>
    <url>%2F2017%2F03%2F05%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[什么是自定义异常，为什么要使用自定义异常，使用自定义异常有哪些好处，又有那么缺点呢? 为什么要使用自定义异常 使用自定义异常类就统一了对外异常展示的方式 某些校验或者问题时，需要直接结束掉当前的请求，这时便可以通过抛出自定义异常来结束 不符合我们项目的业务逻辑抛出异常 可以隐藏底层的异常，这样更安全，异常信息也更加的直观 ###自定义异常的缺点 须编程人员在代码中利用异常处理机制针对性处理 增加了一些开发成本和工作量 如何自定义异常已知Java中所有Exception及Error都是Throwable的子类，自定义异常： 自定义检查性异常类，继承 Exception 类 自定义运行时异常类，继承 RuntimeException 类 12345678910111213141516171819202122232425262728293031323334353637public class TelinxException extends Exception &#123; private static final long serialVersionUID = -4712442758704995601L; private String errCode; private String errMsg; public TelinxException() &#123; super(); &#125; public TelinxException(String message, Throwable cause) &#123; super(message, cause); &#125; public TelinxException(String message) &#123; super(message); &#125; public TelinxException(Throwable cause) &#123; super(cause); &#125; public TelinxException(String errCode, String errMsg) &#123; super(errCode + ":" + errMsg); this.errCode = errCode; this.errMsg = errMsg; &#125; public String getErrCode() &#123; return this.errCode; &#125; public String getErrMsg() &#123; return this.errMsg; &#125;&#125; 运用： 123456789101112131415public static void main(String[] args) &#123; try &#123; //假设此处业务校验出错，然后抛出一场 System.out.println("此处做业务校验"); String errCode = "00000AA1"; String errMsg = "身份证不能为空"; throw new TelinxException(errCode, errMsg); &#125; catch (TelinxException e) &#123; e.printStackTrace(); //异常捕获后尽量要处理，比如通知失败操作，让用户感到友好，而不是放任错误在此输出 &#125;&#125;//输出com.telinx.cglib.TelinxException: 00000AA1:身份证不能为空 at com.telinx.cglib.TelinxException.main(TelinxException.java:45) 参考： Java异常之自定义异常 #]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Spring——注解原理]]></title>
    <url>%2F2017%2F03%2F03%2F%E8%81%8A%E8%81%8ASpring%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[如果阅读本文前对Java注解没有比较充分的认识，推荐先阅读聊聊Java——注解，在此就不再详细介绍注解的基本知识了。本文主要是对Spring注解原理进行详细剖析与实现，以助于读者对Spring注解有更充分的掌握。 注解的基本概念Annotation（注解）是Java提供了一种元程序中的元素关联任何信息和着任何元数据（metadata）的途径和方法。Annotion是一个接口，程序可以通过反射来获取指定程序元素的Annotion对象，然后通过Annotion对象来获取注解里面的元数据。 Annotation是一种接口，通过反射机制相关的API来访问Annotation信息，相关类根据这些信息来决定如何使用该程序元素或改变它们的行为。 Spring注解的处理策略spring主要有两种处理策略，如下： 类级别的注解： @Component：指组件，当组件不好归类的时候，我们可以使用这个注解进行标注 @Repository：用于标注数据访问组件 @Controller：用于标注控制层组件 @Service：用于标注业务层组件 @ManagedBean：其和@Component完全相同，唯一不同的就是名字和创建者（一个是Spring，一个是Java EE规范） @Named：不仅可以用于依赖注入来指定注入的Bean的标识符，还可以用于定义Bean。即注解在类型上表示定义Bean，注解在非类型上（如字段）表示指定依赖注入的Bean标识符 Spring容器根据注解的过滤规则扫描读取注解Bean定义类，并将其注册到Spring IoC容器中。 类内部的注解 @Autowire：装配bean，默认按类型装配，如果我们想使用名称装配可以结合@Qualifier注解进行使用 @Resource：装配bean，默认安照名称进行装配，如果name属性一旦指定，就只会按照名称进行装配 @Value：获取properties文件中的配置值 @Qualifier: @RequestMapping @RequestParam @ModelAttribute @Cacheable @CacheFlush @PostConstruct @PreDestroy @scope @SessionAttributes @InitBinder @Required @qualifier SpringIoC容器通过Bean后置注解处理器解析Bean内部的注解。 在此就不详细介绍每个注解的使用了，可以参考聊聊Spring——各种注解介绍。 Spring注解配置JavaBean的全过程下面的示例来简单的讲述Spring注解原理: 步骤： 定义注解 定义要被注入的DAO 定义带有注解的服务类 定义注解处理器 SAX读取配置文件(XML)中管理的bean 通过反射newInstance实例化bean 注解处理器通过反射依赖注入 未完待续 参考： http://blog.csdn.net/hongweigg/article/details/51495566 http://www.cnblogs.com/Johness/archive/2013/04/17/3026689.html http://www.cnblogs.com/lsx1993/p/4793124.html http://blog.csdn.net/u010987379/article/details/52152795]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——mutable和immutable]]></title>
    <url>%2F2017%2F02%2F10%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94mutable%E5%92%8Cimmutable%2F</url>
    <content type="text"><![CDATA[不可变的（Immutable）——这个类的实例是不可变的，所以，不需要外部的同步。这样的例子包括了String、Long、和BigInteger（来源：Effective Java 中文版246页）。 什么是Immutable Objects和mutable ObjectImmutable Objects(不可变对象)即对象一旦被创建，它的状态(对象的属性值)就不能改变，反之即为mutable(可变对象)。 不可变对象的类即为不可变类(Immutable Class)，Java平台类库中包含许多不可变类，如String、基本类型的包装类（Long、Integer、Float、Short、Boolean、Byte、Character）、BigInteger和BigDecimal等。 对于String（线程安全）和StringBuilder（线程不安全），String属于immutable类，每次对String对象的修改都将产生一个新的String对象，而原来的对象保持不变。而StringBuilder属于mutable类，因为每次对于它的对象的修改都作用于该对象本身，并没有产生新的对象。 mutable Objects与Immtable Objects区别及特点Immtable Objects特点： 对象创建以后其状态不能修改 对象的所有域都是final类型 对象是正确创建的(在对象的创建期间，this引用没有逸出) Immtable Objects优缺点： 构造、测试和使用都很简单 线程安全且没有同步问题，不需要担心数据会被其它线程修改 当用作类的属性时不需要保护性拷贝 可以很好的用作Map键值和Set元素 只需要计算一次hashCode，因为immuable object的内部成员不发生变化 最大的缺点就是创建对象的开销，因为每一步操作（任何一个属性的改变）都会产生一个新的对象 mutable Objects特点： 对象创建以后其状态可以修改 必须提供setter方法以修改内部状态 mutable Objects优缺点： 线程不安全，如果访问，必须小心的加锁 需要保护性拷贝 必须每次计算hashCode 对之操作时开销相比Immutable对象更小，因任何一个属性的改变只需修改一个属性值就行了 mutable与immtable使用场景当考虑因不停创建新对象的性能问题时，经常采用的策略是提供immutable object，同时再提供一个辅助的mutable object，例如高性能计算时，使用mutable object进行计算，然后把结果在转换成immutable object。 在 通信系统的组件间进行消息传递，将消息对象设计成不可变的是明智的。 当无需考虑因不停创建新对象的性能问题时，我们可以尽量使用immutable object。 如何自定义一个immtable Objects自定义一个immtable Objects遵循以下规则： 类应该定义成final，避免被继承。将类声明为final (强不可变类)，或者将所有类方法加上final(弱不可变类)。或者使用静态工厂并声明构造器为private。 声明属性为 private 和 final 。 不要提供任何可以修改对象状态的方法：不仅仅是set方法，还有任何其它可以改变状态的方法。 如果类有任何可变对象属性，那么当它们在类和类的调用者间传递的时候必须被保护性拷贝。如果某一个类成员不是原始变量(primitive)或者不可变类，必须通过在成员初始化(in)或者get方法(out)时通过深度clone方法，来确保类的不可变。 错误的写法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Date;/** * Message是一个不可变类，实例化之后没有办法改变它的状态 * */final class Message &#123; /* * 声明为final的基本类型数据总是不可变的 */ private final Integer msgId; private final String msgType; /* * 可变的对象属性. 在这种情况下, 这个可变属性只能被这个类改变。 * (在其它情况下, 允许在原生类外部改变一个属性是很有意义的; * 这种情况就是当属性作为其它地方创建的一个对象引用) */ private final Date createdAt; public Message(Integer msgId, String msgType, Date createdAt)&#123; this.msgId = msgId; this.msgType = msgType; this.createdAt = createdAt; &#125; /** * @return 返回一个基本类型值,调用者可以随意改变返回值,但是不会影响类内部 */ public Integer getMsgId() &#123; return msgId; &#125; /** * @return 返回一个Immutable对象,调用者可以随意改变返回值,但是不会影响类内部 */ public String getMsgType() &#123; return msgType; &#125; /** * * 返回一个可变对象调用者得到内部属性的一个直接引用. 这通常很危险,因为Date对象既可以 * 被这个类改变也可以被它的调用者改变. 即, 类不再对createdAt拥有绝对的控制。 */ public Date getCreatedAt() &#123; return createdAt; &#125; public static void main(String[] args) &#123; Message msg = new Message(121, "earth", new Date()); Date date = msg.getCreatedAt(); date.setTime(888_888_888L); System.out.println("the value of msg'createdAt is --&gt; " + msg.getCreatedAt().getTime()); System.out.println("the value of date is---&gt; " + date.getTime()); &#125; //输出the value of msg'createdAt is --&gt; 888888888the value of date is---&gt; 888888888 正确的写法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.Date;/** * Message是一个不可变类，实例化之后没有办法改变它的状态 * */final class Message &#123; /* * 声明为final的基本类型数据总是不可变的 */ private final Integer msgId; private final String msgType; /* * 可变的对象属性. 在这种情况下, 这个可变属性只能被这个类改变。 * (在其它情况下, 允许在原生类外部改变一个属性是很有意义的; * 这种情况就是当属性作为其它地方创建的一个对象引用) */ private final Date createdAt; public Message(Integer msgId, String msgType, Date createdAt)&#123; this.msgId = msgId; this.msgType = msgType; /* * 创建createdAt的一个私有拷贝，而不是外部变量的引用 * 这是保持createdAt属性为private的唯一方式, * 并且保护这个类不受调用者对于原始createdAt对象所做任何改变的影响 */ this.createdAt = new Date(createdAt.getTime()); &#125; /** * @return 返回一个基本类型值,调用者可以随意改变返回值,但是不会影响类内部 */ public Integer getMsgId() &#123; return msgId; &#125; /** * @return 返回一个Immutable对象,调用者可以随意改变返回值,但是不会影响类内部 */ public String getMsgType() &#123; return msgType; &#125; /** * 返回属性的一个保护性拷贝.调用者可以任意改变返回的Date对象,但是不会影响类的内部.为什么? * 因为它们没有fDate的一个引用. 更准确的说, 它们返回属性的一个保护性拷贝. 调用者可以任意改变返回的Date对象, * 但是不会使用的是和fDate有着相同数据的另一个Date的拷贝对象 * @return 返回一个可变对象 */ public Date getCreatedAt() &#123; return new Date(createdAt.getTime()); &#125; public static void main(String[] args) &#123; Message msg = new Message(121, "earth", new Date()); Date date = msg.getCreatedAt(); date.setTime(888_888_888L); System.out.println("the value of msg'createdAt is --&gt; " + msg.getCreatedAt().getTime()); System.out.println("the value of date is---&gt; " + date.getTime()); &#125;&#125;//输出the value of msg'createdAt is --&gt; 1502601924525the value of date is---&gt; 888888888 参考： Effective Java中文版 Java 的不可变类 (IMMUTABLE CLASS) 和 可变类 (MUTABLE CLASS) immutable和mutable对象(java)]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>immutable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——代理机制]]></title>
    <url>%2F2017%2F02%2F05%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[我们都知道Spring主要有两大思想，一个是IoC，另一个就是AOP，对于IoC，本文暂且就不讲述了，而对于Spring的核心AOP来说，学习了AOP底层是怎么样的一个原理，我们才可以更好的通过AOP来满足的我们的需求。 什么是代理​ 我们都知道“代购”，很多人可能没有时间或者条件出国想买自己想要的商品，所以催生了代购行业，消费者不需要出国且可以做其他的事情，只需付钱就可以从代购从业者买到我们想要的商品，而自己这是生活中我们常见的代理，而代码中的代理思想也就大致如此。 代理的作用: 为其他对象提供一种代理以控制对这个对象的访问，解决直接访问对象时带来的问题。 代理的优点： 可以隐藏委托类的实现 可以实现调用方与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理 代理涉及角色： 抽象角色：声明真实对象和代理对象的共同接口 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能够代替真实对象 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象 什么是静态代理​ 由程序员创建或由特定工具自动生成源代码，再对其编译，在程序运行前，代理类的.class文件就已经存在了。 ​ 在代理类中实现被代理类实现的所有接口，这样保证了被代理类所能实现的方法，代理类也能实现，保证了两边行为的一致性，代理类就能转型为被代理类，当作被代理类处理。而代理中有被代理类的对象，这样，在代理类的内部实现接口方法时就能调用被代理类的方法，从而进行对被代理类的封装。 12345678910111213141516171819202122232425262728293031323334353637383940414243//接口public interface ISeller &#123; public void sell();&#125;//工厂public class Factory implements ISeller&#123; public void sell()&#123; System.out.println("我们出售此产品"); &#125;&#125;//代理商public class Proxy implements ISeller&#123; private ISeller factory = new Factory(); @Override public void sell() &#123; System.out.println("代理机构下订单"); factory.sell(); System.out.println("厂家通知代理机构已下订单"); &#125;&#125;//实现调用/** * 买一个产品不需要找到厂家，只需找到代理厂商就可以买到要的产品，实际厂家发货 * @ClassName ProxyTest * @Description TODO(这里用一句话描述这个类的作用) * @author pcdalao * @version 1.0.0 */public class ProxyTest &#123; public static void main(String[] args) &#123; ISeller seller = new Proxy(); seller.sell(); &#125;&#125; 什么是动态代理​ 与静态代理类对照的是动态代理类，动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。 ​ 代理类必须实现InvocationHandler接口，对代理实例调用方法时，将对方法调用进行编码并将其指派到它的代理程序的invoke方法。 Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类： Interface InvocationHandler 1234567//该接口中仅定义了一个方法：Object invoke(Object proxy, Method method, Object[] args) //在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，如上例中的request()，args为该方法的参数数组（无参时设置为null）//这个抽象方法在代理类中动态实现。 Proxy 该类即为动态代理类，主要包含如下内容： 123456//构造函数，用于给内部的invocation handler赋值protected Proxy(InvocationHandler h)： //loader是类装载器，interfaces是真实类所拥有的全部接口的数组static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) ：//返回代理类的一个实例，返回后的代理类可以当作被代理类使用（可使用被代理类在Subject接口中声明过的方法）static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) ： 动态代理使用场合： spring的AOP 加事务 加权限 加日志 动态代理步骤 创建一个实现接口InvocationHandler的类，它必须实现invoke()方法 创建被代理的类以及接口 通过Proxy的静态方法newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)创建一个代理 通过代理调用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//创建一个实现接口InvocationHandler的类import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class CommonInvocationHandler implements InvocationHandler &#123; private Object target; public CommonInvocationHandler() &#123; &#125; public CommonInvocationHandler(Object obj) &#123; this.target = obj; &#125; public void setTarget(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("&lt;--------Before Invoke--------&gt;"); Object result = method.invoke(target, args); System.out.println("&lt;--------Before Invoke--------&gt;"); return result; &#125;&#125;//创建被代理的类以及接口public interface Fox &#123; public void doAction();&#125;public class FoxImpl1 implements Fox &#123; @Override public void doAction() &#123; System.out.println("I am Fox1"); &#125;&#125;public class FoxImpl2 implements Fox &#123; @Override public void doAction() &#123; System.out.println("I am Fox2"); &#125;&#125;//调用import java.lang.reflect.Proxy;public class Demo &#123; public static void main(String[] args) &#123; CommonInvocationHandler handler = new CommonInvocationHandler(); Fox fox = null; handler.setTarget(new FoxImpl1()); fox = (Fox) Proxy.newProxyInstance(Fox.class.getClassLoader(), new Class[] &#123; Fox.class &#125;, handler); fox.doAction(); System.out.println("《《《《----------------------------》》》"); handler.setTarget(new FoxImpl2()); fox.doAction(); &#125;&#125;//输出&lt;--------Before Invoke--------&gt;I am Fox1&lt;--------Before Invoke--------&gt;《《《《----------------------------》》》&lt;--------Before Invoke--------&gt;I am Fox2&lt;--------Before Invoke--------&gt; cglib动态代理​ JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。 ​ JDK动态代理与CGLib动态代理最大的不同就是前者是基于接口的代理，后者是类的代理，丢开了接口的枷锁，更加的灵活。 1234567891011121314CGLIB的核心类：Enhancer //主要的增强类MethodInterceptor //主要的方法拦截类，它是Callback接口的子接口，需要用户实现MethodProxy //JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。/*MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法*/public Object intercept(Object object, java.lang.reflect.Method method,Object[] args, MethodProxy proxy) throws Throwable;/*第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//被代理类public class SayHello &#123; public void say() &#123; System.out.println("hello everyone"); &#125;&#125;//代理类import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class CglibProxy implements MethodInterceptor &#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class clazz) &#123; // 设置需要创建子类的类 enhancer.setSuperclass(clazz); enhancer.setCallback(this); // 通过字节码技术动态创建子类实例 return enhancer.create(); &#125; // 实现MethodInterceptor接口方法 public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println("++++++before " + proxy.getSuperName() + "++++++"); System.out.println(method.getName()); // 通过代理类调用父类中的方法 Object result = proxy.invokeSuper(obj, args); System.out.println("++++++after " + proxy.getSuperName() + "++++++"); return result; &#125;&#125;//具体实现public class DoCGLib &#123; public static void main(String[] args) &#123; CglibProxy proxy = new CglibProxy(); // 通过生成子类的方式创建代理类 SayHello proxyImp = (SayHello) proxy.getProxy(SayHello.class); proxyImp.say(); &#125;&#125;//输出++++++before CGLIB$say$0++++++sayhello world++++++after CGLIB$say$0++++++ 参考： http://www.cnblogs.com/jinlin/p/5813801.html http://blog.csdn.net/heyutao007/article/details/49738887 http://blog.csdn.net/yakoo5/article/details/9099133/]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——反射机制]]></title>
    <url>%2F2017%2F02%2F01%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[当我们在使用Idea（如Eclipse）时点击“.”时，Idea自动列出它的属性或方法，很是神奇，这到底是什么原理？其实这就是反射。反射，一种计算机处理方式，是程序可以访问、检测和修改它本身状态或行为的一种能力[来源百度百科]。这两句话如果不是从事计算机行业估计大部分是蒙圈中，从事计算机的不少也是蒙圈中。我的理解是：程序在运行时，需要动态的加载一些类，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。说白了就是动态获取虚拟机JVM内存中类、实例的信息，并且对之操作。 反射是什么​ 反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。官方如此解释： 12Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control. ​ 通过反射，我们可以在动态的获得程序或程序集中每一个类型的成员和成员的信息。 ​ 反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 反射能干什么Java反射框架主要提供的功能： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法） 运行时调用任意一个对象的方法 运行时任意的对任何一个类的所有成员方法、成员变量进行判断和实例化，对任何一个对象的方法调用。 说的那么牛叉，但到底可以用来干嘛呢？如下： 反射机制获取类有三种方法 12345678910//第一种方式： Classc1 = Class.forName("Table"); //第二种方式： //java中每个类型都有class 属性. Classc2 = Table.class; //第三种方式： //java语言中任何一个java对象都有getClass 方法 Table t = new Table(); Classc3 = t.getClass(); //c3是运行时类 (t的运行时类是Table) 创建对象：获取类以后我们来创建它的对象，利用newInstance 1234Class c =Class.forName("Table"); //创建此Class 对象所表示的类的一个新实例 Object o = c.newInstance(); //调用了Table的无参数构造方法. 获取属性：分为所有的属性和指定的属性 1234567891011121314151617181920//获取所有属性Class c = Class.forName("java.lang.Integer"); // 获取所有的属性?Field[] fs = c.getDeclaredFields();// 定义可变长的字符串，用来存储属性StringBuffer sb = new StringBuffer();// 通过追加的方法，将每个属性拼接到此字符串中// 最外边的public定义sb.append(Modifier.toString(c.getModifiers()) + " class " + c.getSimpleName() + "&#123;\n");// 里边的每一个属性for (Field field : fs) &#123; sb.append("\t");// 空格 sb.append(Modifier.toString(field.getModifiers()) + " ");//获得属性的修饰符，例如public sb.append(field.getType().getSimpleName() + " ");// 属性的类型的名字 sb.append(field.getName() + ";\n");// 属性的名字+回车&#125;sb.append("&#125;");System.out.println(sb); 123456789101112//获取部分属性Class c = Class.forName("User"); //获取id属性 Field idF = c.getDeclaredField("id"); //实例化这个类赋给o Object o = c.newInstance(); //打破封装 idF.setAccessible(true); //使用反射机制可以打破封装性，导致了java对象的属性不安全。 //给o对象的id属性赋值"110" idF.set(o, "110"); //set //get System.out.println(idF.get(o)); 获取方法，和构造方法 1234567891011121314151617181920//方法关键字getDeclaredMethods() //获取所有的方法getReturnType() //获得方法的放回类型getParameterTypes() //获得方法的传入参数类型getDeclaredMethod("方法名",参数类型.class,……) //获得特定的方法构造方法关键字getDeclaredConstructors() //获取所有的构造方法getDeclaredConstructor(参数类型.class,……) //获取特定的构造方法//父类和父接口getSuperclass() //获取某类的父类getInterfaces() //获取某类实现的接口 应用实例： Junit JUnit通过反射来遍历包含 @Test 注解的方法，并在运行单元测试时调用它们 Spring框架 123&lt;bean id="fox" class="com.telinx.Fox"&gt; &lt;property name="name" value="Alex" /&gt;&lt;/bean&gt; 当Spring容器处理 bean 元素时，会使用Class.forName(“com.telinx.Fox”)来初始化这个类，并再次使用反射获取 property 元素对应的setter方法，为对象的属性赋值。 servlet 1234&lt;servlet&gt; &lt;servlet-name&gt;foxServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.telinx.Fox&lt;/servlet-class&gt;&lt;servlet&gt; 当Tomcat启动，为应用分配context，容器使用反射创建对象。 反射的预备知识请查看 聊聊Java——java.lang.reflect包熟悉在java.lang.reflect包中有三个重要的类： Field：描述类的域 Method：描述类的方法 Constructor：描述类的构造器 对于public域（包括超类成员）： getFields getMethods getConstructors 对于其它域（包括私有和受保护的成员，不包括超类成员）： gettDeclaredFields gettDeclaredMethods gettDeclaredConstructors 如何使用反射12345678910111213141516171819202122package com.telinx;public class Fox &#123; private String name; public Fox() &#123; &#125; public Fox(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 加载类 1234// 加载类的3种方法Class clazz = Class.forName("com.telinx.Fox");Class clazz1 = new Fox().getClass();Class class2 = Fox.class; 获取类构造函数，并实例化类 1234567891011/*****无参*****/Class clazz = Class.forName("com.telinx.Fox");Constructor c = clazz.getConstructor(null);Fox fox = (Fox) c.newInstance(null);/*****含参私有构造函数*****/Class clazz = Class.forName("com.telinx.Fox");Constructor c = clazz.getDeclaredConstructor(new Class[] &#123; String.class &#125;);// 由于构造函数是 private 的，所以需要屏蔽Java语言的访问检查c.setAccessible(true);Fox fox = (Fox) c.newInstance(new Object[] &#123; "Alex" &#125;); 获取并调用类的无参方法 12345Class clazz = Class.forName("com.telinx.Fox");Constructor c = clazz.getConstructor(null);Fox fox = (Fox) c.newInstance(null);Method method = clazz.getMethod("getName", null);method.invoke(p, null); 获取类的字段 1234567891011Class clazz = Class.forName("com.telinx.Fox");Constructor c = clazz.getDeclaredConstructor(new Class[] &#123; String.class &#125;);c.setAccessible(true);//构造函数是private，需获取控制权限Fox fox = (Fox) c.newInstance(new Object[] &#123; "Alex" &#125;);Field f = clazz.getField("name");Object value = f.get(fox);Class type = f.getType();System.out.println(type);if (type.equals(String.class)) &#123; System.out.println((String) value);&#125; 注解经常与反射结合应用，具体请查看聊聊Java——注解 参考： http://www.jianshu.com/p/53eb4e16d00e http://blog.csdn.net/liujiahan629629/article/details/18013523 http://www.importnew.com/9078.html http://www.sczyh30.com/posts/Java/java-reflection-1/]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——java.lang.reflect包]]></title>
    <url>%2F2017%2F01%2F25%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94java.lang.reflect%E5%8C%85%2F</url>
    <content type="text"><![CDATA[java.lang.reflect包中包含有九个接口、八个类、三个异常、一个错误，本文主要是对重要的几个类进行讲解，以助于更好的理解java反射和动态代理，并且对反射机制加以利用。标注“+”号表示重点理解。 InvocationHandler接口​ 在java的动态代理机制中，有两个重要的类或接口，一个是InvocationHandler、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。 ​ 每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。我们来看看InvocationHandler这个接口的唯一一个方法 invoke 方法： 1234Object invoke(Object proxy, Method method, Object[] args) throws Throwable//proxy: 指代我们所代理的那个真实对象//method: 指代的是我们所要调用真实对象的某个方法的Method对象//args: 指代的是调用真实对象某个方法时接受的参数 Member接口​ Member是一种接口，反映有关单个成员（字段或方法）或构造方法的标识信息。 继承类有Field、Method、Contructor 1234567getDeclaringClass()//返回表示声明由此 Member 表示的成员或构造方法的类或接口的 Class 对象getName() //返回此 Member 表示的底层成员或构造方法的简单名称getModifiers() //作为整数返回由此 Member 所表示的成员或构造方法的 Java 语言修饰符isSynthetic() //如果此成员是编译器引入的，则返回 true；否则，返回 false AccessibleObject类​ AccessibleObject 类是 Field、Method 和 Constructor 对象的基类（父类），提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。对于公共成员、默认（打包）访问成员、受保护成员和私有成员，在分别使用 Field、Method 或 Constructor 对象来设置或获取字段、调用方法，或者创建和初始化类的新实例的时候，会执行访问检查。 AccessibleObject基本作用： 将反射的对象标记为在使用时取消默认Java 语言访问控制检查的能力。 在反射对象中设置accessible标志允许具有足够特权 AccessibleObject类常用方法：设置反射对象的accessible标志指定反射的对象的accessible 标志public void setAccessible(boolean flag)throwsSecurityException{…} 当输入参数flag为true的时候，指示反射对象被使用时取消Java语言访问权限的检查。 当输入参数flag为false的时候，指示反射对象应该实施Java语言访问权限的检查。 Array类数组创建的方法有很多种: 1234int[] anArray ;//这一步只是做了声明，内存中并没分配，这一点是和C/C++不同的地方 anArray = new int[10];//这一步数组才真正建立int[] anArray = &#123;1,2,3&#125;; 数组与Array类的关系: ​ Java中的所有数组都是通过Array类实例化。Array类没有public的构造方法，数组是通过Array的newInstance()方法进行实例化。 123public static Object newInstance(Class&lt;?&gt; componentType, int length) throws NegativeArraySizeException &#123; return newArray(componentType, length);&#125; Constructor类+​ 如果指定的类中没有空参数的构造函数，或者要创建的类对象需要通过指定的构造函数进行初始化。这时怎么办呢？这时就不能使用Class类中的newInstance方法了。既然要通过指定的构造函数进行对象的初始化。就必须先获取这个构造函数——Constructor。Constructor代表某个类的构造方法。 获取构造方法 123Constructor[] cons = Class.forName(“com.telinx.Fox”).getConstructors();Constructor con = Fox.class.getConstructor(String.class,int.class); 创建实例对象: 123456789Fox fox = new Fox(“Alex”,30);Fox fox = (Fox)con.newInstance(“Alex”,30);//Fox.class.newInstance()调用的就是Constructor方法/* 1、创建实例时newInstance方法中的参数列表必须与获取Constructor的方法getConstructor方法中的参数列表一致。 2、newInstance()：构造出一个实例对象，每调用一次就构造一个对象。 3、利用Constructor类来创建类实例的好处是可以指定构造函数，而Class类只能利用无参构造函数创建类实例对象 */ Field类+​ Field类抽象的是各个类的成员变量的总体，提供一个类的域的信息以及访问类的域的接口。Field是不可以被继承的类。注意，Field类不是泛型类。 1234567891011//掌握Field getField(String s);//只能获取公有和父类中公有Field getDeclaredField(String s);//获取该类中任意成员变量，包括私有setAccessible(ture);//如果是私有字段，要先将该私有字段进行取消权限检查的能力。也称暴力访问。set(Object obj, Object value);//将指定对象变量上此Field对象表示的字段设置为指定的新值。Object get(Object obj);//返回指定对象上Field表示的字段的值。 API: 123456789101112131415161718192021222324252627282930313233343536equals(Object obj) //将此 Field 与指定对象比较。get(Object obj) //返回指定对象上此 Field 表示的字段的值。//如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。getAnnotation(Class&lt;T&gt; annotationClass) getBoolean(Object obj) //获取一个静态或实例 boolean 字段的值。getByte(Object obj) //获取一个静态或实例 byte 字段的值。//获取 char 类型或另一个通过扩展转换可以转换为 char 类型的基本类型的静态或实例字段的值。getChar(Object obj) getDeclaredAnnotations() //返回直接存在于此元素上的所有注释。getDeclaringClass() //返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段。//获取 double 类型或另一个通过扩展转换可以转换为 double 类型的基本类型的静态或实例字段的值。getDouble(Object obj) //获取 float 类型或另一个通过扩展转换可以转换为 float 类型的基本类型的静态或实例字段的值。getFloat(Object obj) getGenericType() //返回一个 Type 对象，它表示此 Field 对象所表示字段的声明类型。getInt(Object obj) //获取 int 类型或另一个通过扩展转换可以转换为 int 类型的基本类型的静态或实例字段的值。//获取 long 类型或另一个通过扩展转换可以转换为 long 类型的基本类型的静态或实例字段的值。getLong(Object obj) getModifiers() //以整数形式返回由此 Field 对象表示的字段的 Java 语言修饰符。getName() //返回此 Field 对象表示的字段的名称。//获取 short 类型或另一个通过扩展转换可以转换为 short 类型的基本类型的静态或实例字段的值。getShort(Object obj) getType() //返回一个 Class 对象，它标识了此 Field 对象所表示字段的声明类型。hashCode() //返回该 Field 的哈希码。isEnumConstant() //如果此字段表示枚举类型的元素，则返回 true；否则返回 false。isSynthetic() //如果此字段是复合字段，则返回 true；否则返回 false。set(Object obj, Object value) //将指定对象变量上此 Field 对象表示的字段设置为指定的新值。setBoolean(Object obj, boolean z) //将字段的值设置为指定对象上的一个 boolean 值。setByte(Object obj, byte b) //将字段的值设置为指定对象上的一个 byte 值。setChar(Object obj, char c) //将字段的值设置为指定对象上的一个 char 值。setDouble(Object obj, double d) //将字段的值设置为指定对象上的一个 double 值。setFloat(Object obj, float f) //将字段的值设置为指定对象上的一个 float 值。setInt(Object obj, int i) //将字段的值设置为指定对象上的一个 int 值。setLong(Object obj, long l) //将字段的值设置为指定对象上的一个 long 值。setShort(Object obj, short s) //将字段的值设置为指定对象上的一个 short 值。toGenericString() //返回一个描述此 Field（包括其一般类型）的字符串。 ​ 可参考深入理解 Java 反射：Field （成员变量） Method类+​ Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法）。 ​ 继承的方法（包括重载、重写和隐藏的）会被编译器强制执行，这些方法都无法反射。因此，反射一个类的方法时不考虑父类的方法，只考虑当前类的方法。 ​ 可参考深入理解 Java 反射：Method （成员方法） Modifier类​ Modifier类是位于java.lang.reflect(see)反射包下的一个类，它提供了有关类或成员变量（字段、方法、构造等）的访问修饰符的信息。​ 各成员变量都会有一个getModifiers()方法，getModifiers()方法返回一个包含标志的int值，标志描述了为数组元素应用了哪个修饰符(private、public、protected等)。 ​ 通过观察源码其实不难发现Modifier这个类非常之简单，Modifier类提供了一系列的”isXXX”方法，如下MethodSummary。可以使用这一系列的方法来分析int值。例如，如果参数包含”public”修饰符，静态方法isPublic()就返回true；否则返回false。 1234public static boolean isPublic(int mod) &#123; return (mod &amp; PUBLIC) != 0; &#125; ... 123456789Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) &#123; int modifiers = method.getModifiers(); if(Modifier.isPublic(modifiers))&#123; System.out.println("public method:" + method); &#125;else if(Modifier.isPrivate(modifiers))&#123; System.out.println("private method:" + method); &#125; &#125; Proxy类​ Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法： 1234567public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException //loader:一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载//interfaces:一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了//h:一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 ###]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——注解]]></title>
    <url>%2F2017%2F01%2F20%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解不是注释，有着很多注释做不到的功能，正是有了注释，代码的读写功能更加的灵活。JavaSE5扩展了反射机制的API之后，我们也就可以快速的构造自定义属于自己的注解处理器。 什么是注解（Annotation）​ Annotation（注解）就是Java提供了一种元程序中的元素关联任何信息和着任何元数据（metadata）的途径和方法。Annotion是一个接口，程序可以通过反射来获取指定程序元素的Annotion对象，然后通过Annotion对象来获取注解里面的元数据。 Annotation(注解)是JDK5.0及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。从某些方面看，annotation就像修饰符一样被使用，并应用于包、类 型、构造方法、方法、成员变量、参数、本地变量的声明中。这些信息被存储在Annotation的“name=value”结构对中。 基本的规则： ​ Annotation不能影响程序代码的执行，无论增加、删除 Annotation，代码都始终如一的执行。 什么是metadata（元数据）： 关于数据的数据 1. 元数据以标签的形式存在于Java代码中 2. 元数据描述的信息是类型安全的，即元数据内部的字段都是有明确类型的 3. 元数据需要编译器之外的工具额外的处理用来生成其它的程序部件 4. 元数据可以只存在于Java源代码级别，也可以存在于编译之后的Class文件内部 注解的分类： 根据注解参数的个数 标记注解:一个没有成员定义的Annotation类型被称为标记注解 单值注解 完整注解 根据注解使用方法和用途 JDK内置系统注解：@Override、@Deprecated、@SuppressWarnnings 元注解:@Target、@Retention、@Documened、@Inheried 自定义注解 要深入学习注解，首先我们须了解Java为我们提供的元注解和相关的定义注解的语法，然后自定义自己的注解，并使用注解。 @Target @Retention @Documened @Inheried 这些类型和他们所支持的类在java.lang.annotaion包中可以找到。 @target​ @target说明了Annotation所修饰的对象范围：Annotation可被用于packages 、types(类、接口、annotation类型)、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 取值(ElementType)有： CONSTRUCTOR:用于描述构造器 FIELD:用于描述域 LOCAL_VARIABLE:用于描述局部变量 METHOD:用于描述方法 PACKAGE:用于描述包 PARAMETER:用于描述参数 TYPE:用于描述类、接口(包括注解类型) 或enum声明 使用实例： 123456789101112131415161718@Target(ElementType.TYPE)public @interface Animal &#123; /** * 数据表名称注解，默认值为类名称 * @return */public String AnimalName() default "biologyName";&#125;@Target(ElementType.FIELD)public @interface FieldColumn &#123;&#125; 注解Animal 可以用于注解类、接口(包括注解类型) 或enum声明 注解FieldColumn仅可用于注解类的成员变量。 @Retention​ @Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。 作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效） 取值（RetentionPoicy）有： SOURCE:在源文件中有效（即源文件保留） CLASS:在class文件中有效（即class保留） RUNTIME:在运行时有效（即运行时保留） Retention meta-annotation类型有唯一的value作为成员，它的取值来自java.lang.annotation.RetentionPolicy的枚举类型值。具体实例如下： 1234567891011121314@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface TableColumn &#123; public String name() default "fieldName"; public String setFuncName() default "setField"; public String getFuncName() default "getField"; public boolean defaultDBValue() default false;&#125; TableColumn注解的的RetentionPolicy的属性值是RUTIME,这样注解处理器可以通过反射，获取到该注解的属性值，从而去做一些运行时的逻辑处理 @Documented​ @Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。 123456789101112131415@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface TableColumn &#123; public String name() default "fieldName"; public String setFuncName() default "setField"; public String getFuncName() default "getField"; public boolean defaultDBValue() default false;&#125; @Inherited​ @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。 ​ 当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。 实例代码： 1234567891011@Inheritedpublic @interface Cloth &#123; public enum ColorType&#123; BULE,RED,GREEN&#125;; String name(); FontColor clothColor() default ColorType.GREEN;&#125; ###自定义注解： ​ 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。 定义注解格式： public @interface 注解名 {定义体} ​ 注解参数的可支持数据类型： 1. 所有基本数据类型（int,float,boolean,byte,double,char,long,short) 2. String类型 3. Class类型 4. enum类型 5. Annotation类型 6. 以上所有类型的数组 Annotation类型里面的参数该怎么设定: 只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型； 参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String; 如果只有一个参数成员,最好把参数名称设为”value”,后加小括号.例:下面的例子FruitName注解就只有一个参数成员。 简单的自定义注解和使用注解实例： 123456789101112131415161718192021package annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 水果名称注解 * @author peida * */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitName &#123; String value() default "";&#125; 1234567891011121314151617181920212223242526272829package annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 水果颜色注解 * @author peida * */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitColor &#123; /** * 颜色枚举 * @author peida * */ public enum Color&#123; BULE,RED,GREEN&#125;; /** * 颜色属性 * @return */ Color fruitColor() default Color.GREEN;&#125; 12345678910111213141516171819202122232425262728293031323334package annotation;import annotation.FruitColor.Color;public class Apple &#123; @FruitName("Apple") private String appleName; @FruitColor(fruitColor=Color.RED) private String appleColor; public void setAppleColor(String appleColor) &#123; this.appleColor = appleColor; &#125; public String getAppleColor() &#123; return appleColor; &#125; public void setAppleName(String appleName) &#123; this.appleName = appleName; &#125; public String getAppleName() &#123; return appleName; &#125; public void displayName()&#123; System.out.println("水果的名字是：苹果"); &#125;&#125; 注解元素的默认值： 注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。例如： 12345678910111213141516171819202122232425262728293031323334353637package annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 水果供应者注解 * @author peida * */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitProvider &#123; /** * 供应商编号 * @return */ public int id() default -1; /** * 供应商名称 * @return */ public String name() default ""; /** * 供应商地址 * @return */ public String address() default "";&#125; ​ 定义了注解，并在需要的时候给相关类，类属性加上注解信息，如果没有响应的注解信息处理流程，注解可以说是没有实用价值。如何让注解真真的发挥作用，主要就在于注解处理方法，下一步我们将学习注解信息的获取和处理！ 注解处理器123456789101112131415161718192021222324252627282930313233import java.lang.reflect.Field;public class FruitInfoUtil &#123; public static void getFruitInfo(Class&lt;?&gt; clazz) &#123; String strFruitName = " 水果名称："; String strFruitColor = " 水果颜色："; Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; if (field.isAnnotationPresent(FruitName.class)) &#123; // FruitName FruitName fruitName = (FruitName) field.getAnnotation(FruitName.class); strFruitName = strFruitName + fruitName.value(); System.out.println(strFruitName); &#125; else if (field.isAnnotationPresent(FruitColor.class)) &#123; // FruitColor FruitColor fruitColor = (FruitColor) field.getAnnotation(FruitColor.class); strFruitColor = strFruitColor + fruitColor.fruitColor().toString(); System.out.println(strFruitColor); &#125; &#125; &#125; public static void main(String[] args) &#123; FruitInfoUtil.getFruitInfo(Apple.class); &#125;&#125;/*输出*/ 水果名称：Apple 水果颜色：RED 注解与反射例1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(value = ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface UName &#123; public String value() default "";&#125;/*******************************************************/import java.lang.reflect.Field;public class Dog &#123; @UName("Alex") private String name; private String age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public static void main(String[] args) throws IllegalArgumentException, IllegalAccessException &#123; Dog dog = new Dog(); dog.setName("Mil"); Class clazz = dog.getClass(); Field[] fields = clazz.getDeclaredFields(); // 得到所有的 对象的属性 Method[] methods = clazz.getDeclaredMethods(); for (int i = 0; i &lt; fields.length; i++) &#123; Field field = fields[i]; if(field.isAnnotationPresent(UName.class))&#123; UName uName = field.getAnnotation(UName.class);// 得到属性上的注解 System.out.println("column的注解名称:" + uName.value());// 打印属性上的注解 field.setAccessible(true); field.set(dog, uName.value()); &#125; &#125; System.out.println("--&gt;" + dog.getName()); &#125;&#125; 例2： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.METHOD, ElementType.FIELD &#125;)public @interface Value &#123; String value() default "";&#125;public class User &#123; @Value(value = "Alex") private String name; private String age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; @Value(value = "28") public void setAge(String age) &#123; this.age = age; &#125;&#125;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Test &#123; public static void main(String[] args) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException &#123; User user = new User(); Method[] methods = User.class.getDeclaredMethods(); for (Method method : methods) &#123; boolean hasAnnotation = method.isAnnotationPresent(Value.class); if (hasAnnotation) &#123; Value value = method.getAnnotation(Value.class); method.invoke(user, value.value()); &#125; &#125; Field[] fields = user.getClass().getDeclaredFields(); for (Field filed : fields) &#123; boolean hasAnnotation = filed.isAnnotationPresent(Value.class); if (hasAnnotation) &#123; Value value = filed.getAnnotation(Value.class); filed.setAccessible(true); filed.set(user, value.value()); &#125; &#125; System.out.println("name: " + user.getName()); System.out.println("age: " + user.getAge()); &#125;&#125;/*******输出******/name: Alexage: 28 参考： http://www.cnblogs.com/peida/archive/2013/04/23/3036035.html http://www.cnblogs.com/peida/archive/2013/04/26/3038503.html http://username2.iteye.com/blog/2163633]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——内省机制]]></title>
    <url>%2F2017%2F01%2F20%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94%E5%86%85%E7%9C%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[内省(Introspector)是Java语言对Bean类属性、事件的一种缺省处理方法。例如类 A 中有属性 name, 那我们可以通过 getName,setName 来得到其值或者设置新的值。通过 getName/setName 来访问 name 属性。 直接通过属性的描述器java.beans.PropertyDescriptor类:1234567891011121314151617181920212223242526272829import java.beans.IntrospectionException;import java.beans.PropertyDescriptor;import java.lang.reflect.InvocationTargetException;public class Animal &#123; private String age; public Animal() &#123; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public static void main(String[] args)throws IntrospectionException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; Animal animal = new Animal(); animal.setAge("11"); PropertyDescriptor prop = new PropertyDescriptor("age", Animal.class); // 获取getter方法，反射获取id值 Object str = prop.getReadMethod().invoke(animal); // 获取setter方法，反射赋值 prop.getWriteMethod().invoke(animal, "18"); System.out.println("获取Age值:" + str); System.out.println("赋值ID:" + animal.getAge()); &#125;&#125; 通过类 Introspector 来获取某个对象的 BeanInfo 信息:通过 BeanInfo 来获取属性的PropertyDescriptor ，通过这个PropertyDescriptor 就可以获取某个属性对应的 getter/setter 方法，然后我们就可以通过反射机制来调用这些方法。 12345678910public static void main(String[] args) throws IntrospectionException, IllegalArgumentException, IllegalAccessException,InvocationTargetException&#123; PropertyDescriptor[] propsTem = Introspector.getBeanInfo(Animal.class).getPropertyDescriptors(); Animal animal = new Animal("999"); for(PropertyDescriptor prop : propsTem)&#123; System. out.println("propsTem : Property name: " + prop.getName()+ ", value: "+ prop.getReadMethod().invoke(animal, null)); &#125; &#125; 参考： http://blog.csdn.net/hahalzb/article/details/5972421]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>内省</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——java.beans包下的类]]></title>
    <url>%2F2017%2F01%2F05%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94java.beans%E5%8C%85%E4%B8%8B%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[本文主要摘选beans包下常用的类进行讲解，主要包括BeanDescriptor、BeanInfo、Introspector、Beans、PropertyDescriptor。 BeanDescriptor BeanDescriptor 提供有关 “bean” 的全局信息，其中包括其 Java 类、其 displayName 等等。这是由 BeanInfo 对象返回的描述符种类之一，该对象还返回属性、方法和事件的描述符。 getBeanClass() :获取bean 的 Class 对象 getCustomizerClass() ：获取 bean 的 customizer 的 Class 对象 1234567891011//构造方法public BeanDescriptor(Class&lt;?&gt; beanClass, Class&lt;?&gt; customizerClass) &#123; this.beanClassRef = getWeakReference(beanClass); this.customizerClassRef = getWeakReference(customizerClass); String name = beanClass.getName(); while (name.indexOf('.') &gt;= 0) &#123; name = name.substring(name.indexOf('.')+1); &#125; setName(name);&#125; getBeanClass()、getCustomizerClass()这两个方法的返回值都是返回实例化时的引用对象，也就是说如果实例化引用beanClass和customizerClass的对象的GC回收掉后，这两个方法均返回null。 BeanInfo 一个bean的具体实现者，如果想提供关于这个bean的明确的信息，他可以提供一个实现了BeanInfo接口的BeanInfo类，来提供关于这个Bean的方法，属性，事件等的明确的信息。 123456//主要的方法//返回一个PropertyDescriptor类型的数组PropertyDescriptor[] getPropertyDescriptors();//返回的是一个MethodDescriptor类型的数组MethodDescriptor[] getMethodDescriptors(); 123456789101112131415161718192021222324252627282930313233343536373839//demopublic class Dog &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;import java.beans.BeanDescriptor;import java.beans.BeanInfo;import java.beans.EventSetDescriptor;import java.beans.MethodDescriptor;import java.beans.PropertyDescriptor; public class DogBeanInfo implements BeanInfo&#123; @Override public BeanDescriptor getBeanDescriptor() &#123; BeanDescriptor bd = new BeanDescriptor(Dog.class); bd.setName("Alex"); bd.setDisplayName("Alex's Name"); bd.setShortDescription("Hi, this is First BeanInfo Test!"); return bd; &#125; ... ... ... public static void main(String[] args) throws IntrospectionException &#123; BeanInfo beanInfo = Introspector.getBeanInfo(Dog.class); System.out.println(beanInfo.getBeanDescriptor()); &#125; &#125; 1java.beans.BeanDescriptor[name=Alex; displayName=Alex&apos;s Name; shortDescription=Hi, this is First BeanInfo Test!; beanClass=class com.demo.test.Dog] Introspector Introspector 是一个专门处理bean的工具类.用来获取Bean体系里的 propertiesDescriptor,methodDescriptor，为访问目标Jave Bean支持的属性、事件和方法提供了标准方法。 对于属性Field、方法Method中的每一类信息，Introspector会分别分析目标bean以及其父类，寻找显式或隐式信息并用其构建一个能够全面描述目标bean的BeanInfo对象 通过调用Introspector.getBeanInfo()方法来获得指定类的bean信息 12345678910public static void main(String[] args) throws IntrospectionException, IllegalArgumentException, IllegalAccessException,InvocationTargetException&#123; PropertyDescriptor[] propsTem = Introspector.getBeanInfo(Animal.class).getPropertyDescriptors(); Animal animal = new Animal("999"); for(PropertyDescriptor prop : propsTem)&#123; System. out.println("propsTem : Property name: " + prop.getName()+ ", value: "+ prop.getReadMethod().invoke(animal, null)); &#125; &#125; 请查看“聊聊Java——内省机制” Beans 提供一些通用的 bean 控制方法 12345//重要方法//实例化 JavaBeaninstantiate(ClassLoader cls, String beanName)//通过Introspector（内省）方法isSubclass验证bean是否是targetType的实例public static boolean isInstanceOf(Object bean, Class&lt;?&gt; targetType) PropertyDescriptor 表示JavaBean类通过存储器导出一个属性 12345//主要方法//获得用于读取属性值的方法getpublic synchronized Method getReadMethod()//获得用于写入属性值的方法setpublic synchronized Method getWriteMethod() 1234567891011121314151617181920212223242526272829import java.beans.IntrospectionException;import java.beans.PropertyDescriptor;import java.lang.reflect.InvocationTargetException;public class Animal &#123; private String age; public Animal() &#123; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public static void main(String[] args)throws IntrospectionException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; Animal animal = new Animal(); animal.setAge("11"); PropertyDescriptor prop = new PropertyDescriptor("age", Animal.class); // 获取getter方法，反射获取id值 Object str = prop.getReadMethod().invoke(animal); // 获取setter方法，反射赋值 prop.getWriteMethod().invoke(animal, "18"); System.out.println("获取Age值:" + str); System.out.println("赋值ID:" + animal.getAge()); &#125;&#125; 123456789101112//反射执行get方法ReflectPoint pt1 = new ReflectPoint(7,9);String propertyName = "x";//给一个属性，获取值PropertyDescriptor pd = new PropertyDescriptor(propertyName,pt1.getClass());Method methodGetX = pd.getReadMethod();//Read对应get()方法Object reValue = methodGetX.invoke(pt1);//反射执行set方法String propertyName2 = "y";//给一个属性，设置值PropertyDescriptor pd2 = new PropertyDescriptor(propertyName2,pt1.getClass());Method methodSetY = pd2.getWriteMethod();//Write对应set()方法methodSetY.invoke(pt1,3); 参考： http://www.cnblogs.com/avenwu/archive/2012/02/28/2372586.html]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Java——反射的基石Class类]]></title>
    <url>%2F2017%2F01%2F03%2F%E8%81%8A%E8%81%8AJava%E2%80%94%E2%80%94Class%2F</url>
    <content type="text"><![CDATA[预备知识：Java程序在运行时，系统一直对所有的对象进行所谓的运行时类型标识（提供了运行时确定对象类型及转换指针或者引用类型的方法，保证了面向对象语言中使用多态时能获得更合适的空间和效率），即所谓的RTTI。 这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。 即： Class类也是类的一种，只是名字和class关键字高度相似。Java是大小写敏感的语言 Class类的对象内容是你创建的类的类型信息，比如你创建一个shapes类，那么，Java会生成一个内容是shapes的Class类的对象 Class类的对象不能像普通类一样，以 new shapes() 的方式创建，它的对象只能由JVM创建，因为这个类没有public构造函数 Class类的作用是运行时提供或获得某个对象的类型信息，和C++中的typeid()函数类似。这些信息也可用于反射 Class类原理​ 所有的java类都是继承了object这个类，在object这个类中有一个方法：getclass()，这个方法是用来取得该类已经被实例化了的对象的该类的引用，这个引用指向的是Class类的对象。 ​ 我们自己无法生成一个Class对象（构造函数为private)，而 这个Class类的对象是在当各类被调入时，由 Java 虚拟机自动创建 Class 对象，或通过类装载器中的 defineClass 方法生成。我们生成的对象都会有个字段记录该对象所属类在CLass类的对象的所在位置。如下图： Class和class的区别 class：Java中的类用于描述一类事物的共性，该类事物有什么属性，没有什么属性，至于这个属性的值是什么，则由此类的实例对象确定，不同的实例对象有不同的属性值。 Class：指的是Java程序中的各个Java类是属于同一类事物，都是Java程序的类，这些类称为Class。例如人对应的是Person类，Java类对应的就是Class。Class是Java程序中各个Java类的总称；它是反射的基石，通过Class类来使用反射。 得到Class的对象的三种方法 调用Object类的getClass()方法来得到Class对象，这也是最常见的产生Class对象的方法” 12MyObj x = new MyObj();Class c1 = x.getClass(); 使用Class类的中静态forName()方法获得与字符串对应的Class对象: 1Class c2=Class.forName("MyObj"); //MyObj必须是接口或者类的名字 获取Class类型对象的第三个方法非常简单。如果T是一个Java类型，那么T.class就代表了匹配的类对象 123Class cl1 = String.class;Class cl2 = Integer.class;Class cl3 = Double[].class; 注意：Class对象实际上描述的只是类型，而这类型未必是类或者接口。例如上面的int.class是一个Class类型的对象。由于历史原因，数组类型的getName方法会返回奇怪的名字。 Class类的常用方法 getName() 一个Class对象描述了一个特定类的属性，Class类中最常用的方法getName以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。 newInstance() Class还有一个有用的方法可以为类创建一个实例，这个方法叫做newInstance()。例如： 1x.getClass.newInstance();//创建了一个同x一样类型的新实例。newInstance()方法调用默认构造器（无参数构造器）初始化新建对象 getClassLoader() 返回该类的类加载器 getComponentType() 返回表示数组组件类型的 Class getSuperclass() 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class isArray() 判定此 Class 对象是否表示一个数组类 反射的关系反射机制： ​ 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制 反射的功能： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法 Class与反射： Java程序在运行时，虚拟机通常使用运行时类型信息选准正确方法去执行，而用来**保存这些类型信息的类**是Class类。 ​ ClassLoader找到了需要调用的类时，就会加载它，然后根据.class文件内记载的类信息来产生一个与该类相联系的独一无二的Class对象。该Class对象记载了该类的字段，方法等等信息。以后jvm要产生该类的实例，就是根据内存中存在的该Class类所记载的信息。基于这些机制，也就实现了反射。 反射API Class类：代表一个类 Field类：代表类的成员变量（成员变量也称为类的属性） Method类：代表类的方法 Constructor类：代表类的构造方法 Array类：提供了动态创建数组，以及访问数组的元素的静态方法 Class类的基本方法 getClassLoader()获取该类的类装载器。 getComponentType() 如果当前类表示一个数组，则返回表示该数组组件的 Class 对象，否则返回 null。 getConstructor(Class[])返回当前 Class 对象表示的类的指定的公有构造子对象。 getConstructors()返回当前 Class 对象表示的类的所有公有构造子对象数组。 getDeclaredConstructor(Class[])返回当前 Class 对象表示的类的指定已说明的一个构造子对象。 getDeclaredConstructors()返回当前 Class 对象表示的类的所有已说明的构造子对象数组。 getDeclaredField(String)返回当前 Class 对象表示的类或接口的指定已说明的一个域对象。 getDeclaredFields()返回当前 Class 对象表示的类或接口的所有已说明的域对象数组。 getDeclaredMethod(String, Class[])返回当前 Class 对象表示的类或接口的指定已说明的一个方法对象。 getDeclaredMethods()返回 Class 对象表示的类或接口的所有已说明的方法数组。 getField(String)返回当前 Class 对象表示的类或接口的指定的公有成员域对象。 getFields()返回当前 Class 对象表示的类或接口的所有可访问的公有域对象数组。 getInterfaces()返回当前对象表示的类或接口实现的接口。 getMethod(String, Class[])返回当前 Class 对象表示的类或接口的指定的公有成员方法对象。 getMethods()返回当前 Class 对象表示的类或接口的所有公有成员方法对象数组，包括已声明的和从父类继承的方法。 getModifiers()返回该类或接口的 Java 语言修改器代码。 getName()返回 Class 对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。 getResource(String)按指定名查找资源。 getResourceAsStream(String)用给定名查找资源。 getSigners()获取类标记。 getSuperclass()如果此对象表示除 Object 外的任一类, 那么返回此对象的父类对象。 isArray()如果 Class 对象表示一个数组则返回 true, 否则返回 false。 isAssignableFrom(Class)判定 Class 对象表示的类或接口是否同参数指定的 Class 表示的类或接口相同，或是其父类。 isInstance(Object)此方法是 Java 语言 instanceof 操作的动态等价方法。 isInterface()判定指定的 Class 对象是否表示一个接口类型。 isPrimitive()判定指定的 Class 对象是否表示一个 Java 的基类型。 newInstance()创建类的新实例。 toString()将对象转换为字符串 Class的一些使用技巧 forName和newInstance结合起来使用，可以根据存储在字符串中的类名创建对象 1234Object obj = Class.forName(s).newInstance();/*同时想到创建对象另两种方法*/MyObj x = new MyObj();MyObj x1 = x.clone(); 虚拟机为每种类型管理一个独一无二的Class对象。因此可以使用==操作符来比较类对象 123if(x.getClass() == MyObj.class)&#123; ...&#125; ​ 参考 http://www.cnblogs.com/bethunebtj/p/4680532.html http://blog.csdn.net/ghuilee/article/details/45821537 ​]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
